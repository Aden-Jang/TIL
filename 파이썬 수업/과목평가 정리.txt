- Truthy, Falsy(False는 아니지만 False로 취급되는 다양한 값 - 0, 0.0, (), [], {}, None, "" 등)


- 여러가지 연산
+ - 덧셈
- - 뺄셈
* - 곱셉
/ - 나눗셈
// - 몫
** - 거듭제곱
% - 나머지
괄호가 먼저 *,/ +,-순서로 계산
부동 소수점 -> 2진수를 사용하다보니 실수 처리할 때 생기는 오류
문자형은 더해진 것들이 붙어서, 숫자는 연산되어 나옴
논리 연산자의 단축평가 -> 
and연산자는 첫 값이 False 이면 무조건 False, 첫값 반환 반대면 나중값 반환
or연산자는 첫 값이 True 이면 무조건 True, 첫값 반환 반대면 나중값 반환


- 각 자료형의 특징(반복가능, 변경가능)
변경 불가능 - string, integer, float, boolean, tuple, range
시퀀스형(순서가 있음) 
1. 리스트 - 생성 이후 내용 변경 가능(가변 자료형)(mutable)
2. 튜플 - 변경 불가능(불변 자료형)(immutable)
3. 레인지 - 변경 불가능(불변 자료형)(immutable)
4. 문자열 - 변경 불가능(불변 자료형)(immutable)
비시퀀스형(순서가 없음)
1. 세트 - 변경 가능(가변 자료형)(mutable)
2. 딕셔너리 - 변경 가능(가변 자료형) (py3.7버전부터 시퀀스형)(mutable)
	     key는 변경 불가능한 데이터만 활용 가능(string, interger, float, bollean, tuple, range)
모두 순회 가능
enumerate() -> (인덱스, 밸류)형태의 튜플로 반환


- 매개변수(*args, **kwargs)
parameter(매개변수, 인수) - 함수를 정의할 때 함수 내부에서 사용되는 변수
argument(인자) - 함수를 호출할 때 넣어주는 값
Positional Arguments - 인자는 위치에 따라 함수내에 전달됨
Keyword Arguments - 직접 변수의 이름으로 특정 인자를 전달, Keyword Arguments 다음 Positional을 쓸 수 없음
Defalult Arguments Values - 함수 정의 시 기본값을 지정하여 호출할 때 인자를 설정하지 않아도 호출됨
정해지지 않은 여러개의 Arguments처리는 애스터리스크 혹은 언패킹 연산자라고 불리는 * 덕분

가변인자(*args) - 여러개의 Positional Argument를 하나의 필수 parameter로 받아 사용
패킹 - 여러개의 데이터를 묶어서 변수에 할당
언패킹 - 시퀀스 속의 요소들을 여러개의 변수에 나누어 할당, 변수의 개수와 요소의 개수가 동일해야함, 왼쪽의 변수에 애스터리스크(*)를 붙이면, 할당하고 남은 요소를 리스트에 담을 수 있음

가변 키워드 인자(**kwargs) - 몇 개의 키워드 인자를 받을 지 모르는 함수를 정의할 때 사용, 딕셔너리로 묶여 처리됨 - key는 ''안쓰고 넣고, value는 씀


- 딕셔너리 값에 대한 접근 방법 두가지
.get(key) -> 값이 없어도 keyerror 발생 안함, None으로 반환
dict[key] -> 값이 없으면 keyerror 발생


- 얕은 복사, 깊은 복사
대입 연산자(=)를 쓰면 할당, 객체의 주소가 같아 복사본을 변경해도 모두 변경됨
얕은 복사는 슬라이스 연산자를 활용하여 같은 원소를 가지지만 주소가 다르게 복사함, 복사하는 리스트의 원소가 주소를 참조하는 경우는 복사본을 변경해도 같이 변경될 수 있음
a=[1,2,['a','b']]
b=a[:]
print(a,b) -> [1,2,['a','b']] [1,2,['a','b']]
b[0] =5
print(a,b) # [1,2,['a','b']] [5,2,['a','b']]
b[2][0] = 0 
print(a,b) -> [1,2,['0','b']] [5,2,['0','b']]
깊은 복사는 copy의 deepcopy를 사용. 아예 다른 복사본을 만들어 전혀 상관 없음


- 객체와 인스턴스(생성자와 속성, 메서드)
