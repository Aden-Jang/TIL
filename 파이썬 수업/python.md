
# Python

## 프로그래밍 학습 마인드셋(OT)

- **개념 구조화** 하기 in 프로그래밍
    - 개념의 정의
    - 개념의 포함관계
    - 두 개념의 차이점
- 기본기 탄탄하게 쌓기
    - 코드를 작성하지 않고 프로그래밍 배우기는 불가능.
    - 지루하더라도 기본기가 중요!!!
- **동료 학습**(Peer Learning)
    - 상호 작용을 기반으로 한 학습
    - 친구에게 배운 개념 설명
    - 친구 코드의 에러 함께 해결
    - 모르는 내용을 서로 질문/대답 하면서 지식의 빈틈 채우기
    - 장점
        - 현업 기반의 학습 환경
        - 실제 회사에서도 함께 일하게 됨
        - 커뮤니케이션 스킬이 증진
        - 즉 동료학습이 취업에 도움이 된다~

---

## 프로그래밍이란?

### 프로그래밍의 정의

- 프로그램을 만드는 행위(프로그램+ing)
- 컴퓨터에게 일을 시키기 위해서 프로그램을 만드는 행위 - 프로그램을 만드는 사람은 **프로그래머(소프트웨어 개발자)**
    - 소프트웨어 , 코딩 - 엄밀히 따지면 다르지만 프로그램과 유사한 의미로 사용

#### 프로그램이란?

- 특정 작업을 수행하는 일련의 명령어들의 모음
- 컴퓨터가 해야할 일들이 순서대로 적혀있는 것

#### 프로그래밍 언어란?

- 언어란?
    - 자신의 생각을 나타내고 전달하기 위해 사용하는 체계
    - 문법적으로 맞고, 언어 공동체 내에서 이해될 수 있는 말의 집합
- 컴퓨터는 기계어로 소통.
    - 기계어 - 0과 1로 모든 것을 표현(2진법)
    - 처음 컴퓨터가 발명될 때 전기 신호로 전기가 들어왔는지(1), 안들어왔는지(0) 확인하는 방법으로 시작 - 지금까지 사용
    - 하지만 프로그래밍 하기 위해 기계어를 알 필요는 없다.
- 기계어의 대안으로 사람이 이해할 수 있는 새로운 언어 - **프로그래밍 언어** 개발
    - 사람이 이해할 수 있는 문자로 구성
    - 기본적인 규칙과 문법이 존재
- 프로그래밍 언어의 구성
    - 소스코드
        - 프로그래밍 언어로 작성된 프로그램
    - 번역기(interpreter 또는 compiler)
        - 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역
        - **파이썬의 경우 인터프리터**를 사용
    
---

## 파이썬이란?

### 파이썬을 배워야 하는 이유

- 알고리즘 코딩 테스트에 유리
    - 알고리즘 코딩테스트에서는 Python이 2위(선호도 조사)
    - 코딩 테스트의 유형이 다양해지면서 변칙적인 유형에 대응하기 쉬운 파이썬이 유리해짐 - 결과 최근 3년간 파이썬이 급증
    - 대회를 준비한다면 C를 추천하지만 입사를 위한 코테는 Python추천
- 구현 코딩 테스트에 유리
    - 유용한 라이브러리 중 최소한만 사용해 프로그램을 개발할 수 있어 가장 유리한 언어
    - 실행시간이 매우 중요한 문제 유형이 아닌 이상 파이썬으로 코테를 준비하는 것이 최선의 선택이다.
- 가장 인기 많은 언어
    - 프로그래밍의 인기 척도를 사용하는 PYPL Index, TIOBE Index에서 2022년 6월기준 1위
    - AI 개발, 데이터 분석, 웹 프로그래밍, 업무 자동화 등 활용분야가 늘어나 많은 회사에서 도입 중
- 그나마 배우기 쉽다
    - 파이썬은 다른 프로그래밍 언어보다 문법이 간결하고, 유연함(변수에 별도의 타입 저장이 필요 없음)
    - 비교적 쉽게 마스터하고, 프로그래밍 사고에 집중할 수 있음

---

### 파이썬의 특징

- **인터프리터**(Interpreter) 언어
    - 파이썬은 소스코드를 기계어로 변환할 때 통역(interprete) 하듯이 1줄씩 변환
- **객체 지향 프로그래밍**(Object Oriented Programming)
    - 현대 프로그래밍의 기본적인 설계 방법론으로 자리잡은 객체 지향 프로그래밍
    - 모든 것이 객체로 구현되어 있음

---

### 파이썬 개발환경

- 파이썬 개발 환경 종류
    - IDE(Intergrated development encironment)
        - 통합개발 환경의 약자로 개발에 필요한 다양하고 강력한 기능들을 모아둔 프로그램
        - 보통 개발은 IDE를 이용함
        - VSCode, Pycharm등
    - Jupyter Notebook
        - 문법 학습을 위한 최적의 도구로, 소스코드와 함께 실행 결과와 마크다운 저장 가능
        - open source기반의 웹 플랫폼 및 어플리케이션으로 파이썬을 비롯한 다양한 프로그래밍 언어를 지원하며 셀단위의 실행이 가능한 것이 특징
        - 인공지능 할때 자주 사용 수업에서는 실시간으로 결과를 확인하며 학습하는데 용이해 사용 예정
    - IDLE(Intergrated Development and Learning Environment)
    - 코딩
        - 파이썬: Jupyter notebook, VSCode(실시간으로 결과를 확인하며 학습하기 위함)
        - 웹: VSCode
        - 알고리즘: Pycharm

---

### 파이썬 기초문법

#### 코드 스타일 가이드

- 파이썬에서 제안하는 스타일 가이드(강의에서 사용)
    - PEP8(https://www.python.org/dev/peps/pep-0008/)
    - 각 회사/ 프로젝트마다 따로 스타일 가이드를 설정하기도 함
    - Google Style guide 등
- 스타일 가이드를 지키지 않으면 코드의 가독성이 떨어진다.

#### 들여쓰기

- space 4칸(tab)
- 문장을 구분할 때 중괄호 대신 들여쓰기 사용

#### 주석("필수로 해야할 것")

- 코드에 대한 설명
- 코드에 영향을 주지 않으며 오로지 개발자를 위함
- 코드 이해에 도움이 되어 분석, 수정 용이해짐
- 실행에 영향을 미치지 않을 뿐더러 속도를 느리게 하지 않으며 용량을 늘리지 않음
- 한줄 주석
    - 내용 앞에 #을 입력
    - 한줄을 온전히 사용 가능, 코드 뒤에만도 사용 가능
- 여러줄 주석
    - 한 줄씩   # 을 이용하거나 """ 또는 ''' 으로 묶어서 표현
- 주석의 장점
    - 개발자에게 주석을 다는 습관은 매우 중요
    - 코드의 내용을 잘 이해할 수 있도록 작성
    - 가독성을 저해할 정도로 무분별한 사용은 자제
    - 코드를 쉽게 이해할 수 있어 코드 수정 및 협업에 유리

---

## 변수

컴퓨터가 값을 저장하고 이름을 매김 ex) dust = 60

데이터 저장 → 처리

### 변수란?

- 데이터를 저장하기 위해 사용
- 변수를 사용하면 복잡한 값들을 쉽게 사용할 수 있음(추상화)
- 동일 변수에 다른 데이터를 언제든 할당(저장)할 수 있기 때문에 ‘변수’라고 불림

**추상화** (변수를 사용해야하는 이유)

- 코드의 가독성 증가
- 숫자를 직접 적지 않고 의미 단위로 작성 가능
- 코드 수정이 용이해짐 - 가격 변경이 있더라도 1곳만 수정하면 됨
 
```
- 만약에 아메리카노 1잔을 시킨다?
    - print(2000) # 2000
- 아메리카노 1잔과 쿠키 1개
    - print(2000 + 2000) # 4000
- 모카 2잔에 레몬에이드 3잔 케잌 5개
    - print(3000 * 2 + 3500 * 3 * 4000 * 5) # 36500
```
- 실행하면 결과는 잘 나오지만 문제가 있음
    - 일일이 값을 넣는 것이 불편함
        - 숫자를 입력하다 보면 오타가 나서 잘못된 값을 넣을 수 있음
    - 코드를 알아보기 힘듦
        - 다른 사람이 코드를 이해할 수 없음
    - 고치기 어려운 코드
        - 만약 아메리카노 가격이 변경된다면?
            - 코드 여러곳을 수정해야함
- 간단한 코드지만 실제로 코드가 복잡해지면 심각한 문제

##### 변수의 할당

- 변수는 할당 연산자(=)를 통해 값을 할당(assignment)
```python
- 같은 값을 동시에 할당할 수 있음
    - americano = cookie = 2000
- 다른 값을 동시에 할당할 수 있음
    - americano, mocha = 2000, 3000
```
##### 각 변수의 값을 바꿔서 저장

- x = 10 y = 20 일 때 각각 값을 바꿔서 저장하는 코드

```python
# 방법 1) 임시 변수 활용
x, y = 10, 20
tmp = x
x = y
y = tmp
print(x, y) # 20, 10

# 방법 2) Pythonic!
x, y = 10, 20
y, x = x, y
print(x, y) #20 10
```

---

## **식별자**

- 변수 이름 규칙
    - 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성
    - 첫 글자에 숫자가 올 수 없음
    - 길이 제한이 없고, 대소문자를 구별
    - 다음의 키워드(keywords)는 예약어(reserved words)로 사용할 수 없음

![키워드](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%82%A4%EC%9B%8C%EB%93%9C.JPG)

- 내장함수나 모듈 등의 이름도 사용하지 말아야 함
    - print 등
    - 동작을 예상할 수 없게 임의로 값을 할당하게 되므로 범용적이지 않은 코드가 됨

---

## 연산자

#### 산술 연산자

기본적인 사칙연산 및 수식 계산

```python
+ - 덧셈
- - 뺄셈
* - 곱셉
/ - 나눗셈
// - 몫
** - 거듭제곱
```

##### 연산자 우선순위

- 기본적으로 수학에서 우선순위와 같음
- 괄호가 가장 먼저 계산, *,/가 +,-보다 먼저 계산

---

## 자료형

#### 자료형(Datatype) 분류

- 프로그래밍에서는 다양한 종류의 값(데이터)을 쓸 수 있음
    - 사용할 수 있는 데이터의 종류들을 자료형이라고 함

```python
Data Type - Boolean Type(불린형(참거짓))
	  - Numeric Type(수치형) - 정수형(int)
	                        - 실수형(float)
    	                        - 복소수(complex)
	  - String Type(문자열)
```

---

## 수치형

- 정수 자료형(int)
    - 0,100,-200등의 정수
- 진수 표현
    - 2진수(binary) : 0b
    - 8진수(octal) : 0c
    - 16진수(hexadecimal) : 0x
- 실수 자료형(float)
    - 유리수 무리수를 포함한 실수를 다루는 자료형
        - 0.1, 100.0, -0.0001 등
    - 실수의 값을 처리할 때 의도하지 않은 값이 나올 수 있음

```python
print(3.2 - 3.1) # 0.10000000000009
print(1.2 - 1.1) # 0.09999999999987
# 연산의 결과가 0.1이 아니다!
```

- 윈인은 부동 소수점 때문
    - 컴퓨터는 2진수, 사람은 10진법 사용
    - 10진수 0.1은 2진수는 0.0001100110011…같이 무한대로 반복됨
    - 무한대 숫자를 그대로 저장할 수 없어 사람이 사용하는 10진법의 근사값만 표시
    - 0.1의 경우 36028701896397/2**5이며 0.1에 가깝지만 정확히 동일하지 않음
    - 이런 과정에서 예상치 못한 결과가 나타남(Floating point rounding error라고 함)
- 해결책
    - 값을 비교하는 과정에서 정수가 아닌 실수면 주의할 것
    - 매우 작은수보다 작은지를 확인하거나 math 모듈 활용

![부동소수점 해결책](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%20%ED%95%B4%EA%B2%B0%EC%B1%85.JPG)

---

## 문자열 자료형

#### 문자열 자료형의 정의

- 모든 문자는 str타입
- 문자열은 ' 또는 "를 활용하여 표기
    - 문자열을 묶을 때 동일한 문장부호 활용
    - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

**중첩 따옴표**

- 따옴표 안에 따옴표를 표현할 경우
    - 작은따옴표가 들어있는 경우는 큰따옴표로, 큰따옴표가 들어있는 경우는 작은따옴표로 문자열 생성

**삼중 따옴표**

- 작은 따옴표나 큰따옴표를 삼중으로 사용(''', """)
    - 따옴표 안에 따옴표를 넣을 때 여러 줄을 나눠 입력할 떄 편리

##### Escape sequence

- 역슬래시(\\)뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
- 띄어쓰기, 줄 바꿈과 같은 기능을 문자로 표현

```python
\n 줄바꿈
\t 탭
\r 캐리지 리턴
\0 널(NULL)
\\ \
\' 단일인용부호(')
\" 이중인용부호(")
```

EX)

```python
print('철수 \'안녕\' ')
print('이 다음은 엔터. \n 그리고 탭\t탭')
```

#### 문자열 연산

- 덧셈
    - 숫자형 연산 7+6은 13
        - 문자형 연산은 “Hello” + “World” = HelloWorld
    - 문자열을 더하면 문자열을 연결
    - 영어로는 String Concatenation이라고 함
    
- 곱셈
    - 2*3은 2+2+2 = 6
    - 문자열 “Python”*3은?
        - PythonPythonPython

#### String Interpolation(문자열을 변수를 활용해 만드는 법)

- %-formatting - 현재는 잘 안씀
- str.format()
- f-strings - python 3.6부터 이거 씀 위에는 거의 안씀

```python
name = 'Kim'
score = 4.5
print(f'Hello, {name}! 성적은 {score}')
# Hello, Kim! 성적은 4.5
```

- import Datetime - 시간을 다룰 수 있는 모듈

---

### **None**

- 파이썬 자료형 중 하나
- 값이 없음을 표현하기 위해 None 타입이 존재
- 일반적으로 반환값이 없는 함수에서 사용하기도 함

---

### **불린형(Boolean)**

- 논리 자료형으로 참과 거짓을 표현하는 자료형
- True 또는 False를 값으로 가짐
- 비교/논리연산에서 활용됨

---

### **비교 연산자**

- 수학에서 등호와 부등호와 동일한 개념
- 주로 조건문에 사용되며 값을 비교할 때 사용
- 결과는 True/False값을 리턴
    
![비교연산자](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B9%84%EA%B5%90%EC%97%B0%EC%82%B0%EC%9E%90.JPG)

---    

### **논리 연산자**

- 여러가지 조건이 있을 때
    - 모든 조건을 만족하거나(And), 여러 조건 중 하나만 만족해도 될 때(or) 특정 코드를 실행하고 싶을 때 사용
    - 일반적으로 비교연산자와 함께 사용됨
    - and, or, not
- and는 2개다 True인 경우에 True
- or은 1개라도 True면 True
```
- EX) 22시가 지나고 졸리면 True 졸리지 않으면 False →
    - hour=23 , status = ‘sleepy’
        - hour≥22 and status = ‘sleepy’ → True
    - hour=23 , status = ‘nice’
        - hour≥22 and status = ‘sleepy’ → False
```
- 주의할 점 / not연산자
    - Falsy : False는 아니지만 False로 취급되는 다양한 값
        - 0, 0.0, (), [], {}, None, “”(빈 문자열)
            - 1 → True , 0 → False
        - 이외에는 Truthy값으로 취급 
    - 논리연산자도 우선순위 존재
        - not, and, or 순으로 우선순위가 높음

#### 논리 연산자의 단축평가

- 결과가 확실한 경우 두번째 값은 확인하지 않고 첫번째 값 반환
- and 연산에서 첫번째 값이 False인 경우 무조건 False→첫번째 값 반환
- or 연산에서 첫번째 값이 True인 경우 무조건 True → 첫번째 값 반환
    
    ```python
    print(3 and 5) # 5 -> 둘다 True인지 확인하느라
    print(3 and 0) # 0 -> 둘다 True인지 확인하느라
    print(0 and 3) # 0 -> 첫 값이 False이므로 0반환 - 단축평가
    print(0 and 0) # 0
    
    print(5 or 3) # 5 -> 첫 값이 True이므로 5 반환 - 단축평가
    print(3 or 0) # 3 -> 첫 값이 True이므로 5 반환 - 단축평가
    print(0 or 3) # 3 -> 둘다 Fals인지 확인하느라
    print(0 or 0) # 0
    ```

---

## 컨테이너(자료구조)

### 컨테이너란?

- 여러 개의 값(데이터)을 담을 수 있는 것(객체)으로, 서로 다른 자료형을 저장할 수 있음
    - EX) List
- 컨테이너의 분류
    - 순서가 있는 데이터(Ordered) vs. 순서가 없는 데이터(Unordered)
    - 순서가 있다 ≠ 정렬되어 있다.

![컨테이너의 분류](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98%20%EB%B6%84%EB%A5%98.JPG)

---

## 리스트

- 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용 → [] 사용

#### 리스트의 생성과 접근

- 대괄호[] 혹은 list()를 통해 생성
    - 파이썬에서는 어떠한 자료형도 저장 가능하며 리스트 안에 리스트도 넣을 수 있음
    - 생성된 이후 내용 변경이 가능 → 가변 자료형
    - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
    - 값에 대한 접근은 list[i]
- type(자료명) → 자료의 형태를 나타내줌
#### 인덱스
- **인덱스는 0부터 시작**
- 뒤에서부터는 -1부터 사용 가능
- [0:2]이면 0,1 두개(뒤에 값 -1까지)
- [:b] 처음부터 b-1까지
- [a:] a부터 끝까지
- [a : b : c] a부터 b-1까지 c간격으로
---

## 튜플

-  여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용 → ()사용
- 리스트와 차이점은 생성 후, 담고있는 값 변경이 불가(불변 자료형)

#### 튜플 생성과 접근

- 소괄호(()) 혹은 tuple()을 통해 생성
- 튜플은 수정 불가능한 시퀀스로 인덱스로 접근 가능
- 값에대한 접근은 my_tuple[i]

#### 튜플 생성 주의사항

- 단일 항목의 경우
    - 하나의 항목으로 구성된 튜플을 생성 시 값 뒤에 쉼표를 붙여야함
- 복수 항목의 경우
    - 마지막 항목에 붙은 쉼표는 없어도 되지만, 넣는 것을 권장(Trailing comma)

#### 튜플 대입

- 우변의 값을 좌변의 변수에 한 번에 할당하는 과정
- 튜플은 일반적으로 파이썬 내부에서 활용
    - 추후 함수에서 복수의 값을 반환할 때에도 활용

---

## Range

### range의 정의

- 숫자의 시퀀스를 나타내기 위해 사용
- 주로 반복문과 함께 사용됨

#### range의 사용 방법

- 기본형 : range(n)
    - 0부터 n-1까지의 숫자의 시퀀스
- 범위 지정 : range(n,m)
    - n부터 m-1까지의 숫자의 시퀀스
- 기본형 : range(n,m,s)
    - n부터 m-1까지 s만큼 증가시키며  숫자의 시퀀스
    - s가 음수이면 거꾸로 감소시키며 나타냄

---

## 슬라이싱 연산자

### 시퀀스를 특정 단위로 슬라이싱

- 인덱스와 콜론을 사용하여 문자열의 특정 부분만 잘라낼 수 있음
- 슬라이싱을 이용하여 문자열을 나타낼 때 콜론을 기준으로 앞 인덱스에 해당하는 문자는 포함되지만 뒤 인덱스에 해당 문자는 미포함

```python
# 리스트
print([1, 2, 3, 5][1:4]) # [2, 3, 5]
# range
print(range(10)[5:8] # range(5, 8)
# 문자열
print('abcd'[2:4]) # cd
```

### 시퀀스를 k간격으로 슬라이싱

```python
# 리스트
print([1, 2, 3, 5][0:4:2]) # [1, 3]
# range
print(range(10)[1:5:3]) # range(1, 5, 3)
# 문자열
print('abcdefg'[1:3:2]) # b
```

### 문자열 슬라이싱 예제

- s=’abcdefghi’
- s[::] → ’abcdefghi’
    - s[0:len(s):1]과 동일
- s[::-1] → ‘ihgfedcba’
    - s[-1:-(len(s)+1):-1]과 동일

---

## 비 시퀀스형 컨테이너

### 셋(Set)

- set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
    - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
    - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
    - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재하지 않음
    - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입 변경, 삭제 가능 → 가변자료형(mutable)

#### 셋 생성

- 중괄호({}) 혹은 set()을 통해 생성
    - 빈 set을 만들기 위해서는 set()을 반드시 활용해야함
- 순서가 없어 별도의 값에 접근할 수 없음

#### 셋 사용하기

- 셋을 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음
    - 단, 이후 순서가 무시되므로 순서가 중요한 경우 사용할 수 없음
- 순서가 중요한 경우는 셋으로 바꾸면 절대 안됨

#### 셋 연산자

```python
| : 합집합
& : 교집합
- : 차집합
^ : 대칭차집합
여집합은 없음
```

---

## 딕셔너리

### **딕셔너리의 정의**

- 키-값 쌍으로 이뤄진 자료형(3.7부터는 ordered, 이하 버전은 unordered)
- Dictionary의 키
    - 키는 변경 불가능한 데이터(immutable)만 활용 가능
        - string, interger, float, boolean, tuple, range
- 각 키의 값
    - 어떠한 형태든 관계없음

### **딕셔너리 생성**

- 중괄호({}) 혹은 dict()을 통해 생성
- key를 통해 value에 접근

---

## 형 변환(Typecasting)

### 형 변환이란?

- 파이썬에서 데이터 형태는 서로 변환할 수 있음
1. 암시적 형 변환(Implicit) - 파이썬이 하면
    - 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우 (**자동**)
        - bool
        - Numeric type (int, float)
    - 절대 의도하면 안됨
2. 명시적 형 변환(Explicit) - 개발자가 하면
    - 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환하는 경우 (**의도적**)
        - int
            - str, float → int
            - 단, 형식에 맞는 문자열만 정수로 변환 가능
        - float
            - str(참고), int → float
            - 단, 형식에 맞는 문자열만 float로 변환 가능
        - str
            - int, float, list, tuple, dict → str
    
![형 변환](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%98%95%EB%B3%80%ED%99%98.JPG)

---
---
## 제어문
- 조건문과 반복문으로 나뉨
- 파이썬은 기본적으로 위에서 부터 아래로 차례대로 명령을 수행
- 특정 상황에서 따라 코드를 선택적으로 실행(분기/조건)하거나 계속하여 실행(반복)하는 제어가 필요함
- 제어문은 순서도 표현 가능
---
### 조건문
- 참/거짓을 판단할 수 있는 조건식과 함께 사용

#### 기본 형식
- 조건에는 참/거짓에 대한 조건식
    - 조건이 참인 경우 이후 들여쓰기 되어있는 코드 블록을 실행
    - 이외의 경우 else이후 들여쓰기 되어있는 코드 블록을 실행
        - else는 선택적으로 활용할 수 있음
```python
num = int(input("숫자 입력"))
if num % 2 == 0:
    print("짝수")
else:
    print("홀수")
```
#### 복수 조건문
- 복수의 조건식을 활용 할 경우 elif를 활용하여 표현함
    ```
    if 조건 :
    elif 조건 :
    ```
#### 중첩 조건문
- 조건문은 다른 조건문에 중첩되어 사용될 수 있음
    - 들여쓰기에 유의하여 작성할 것
        ```
        if 조건 :
            if 조건:
        else:
        ```
#### 조건 표현식
- 조건 표현식을 일반적으로 조건에 따라 값을 정할 때 활용
- 삼항연산자(Ternary Operator)로 부르기도 함
```
true인 경우 값 if 조건 else false인 경우 값
(왼참 if 조건 else 오거)
```
- 실습 - 절댓값을 저장하는 코드
```python
value = num if num >= 0 else -num
```
---
### 반복문
- 특정 조건을 만족할 때까지 같은 동작을 계속 반복하고 싶을 때 사용
#### 반복문의 종류
- while문
    - 종료 조건에 해당하는 코드를 통해 반복문을 종료시켜야 함
- for 문
    - 반복 가능한 객체를 모두 순회하면 종료(별도의 종료 조건이 필요 없음)
- 반복 제어
    - break, continue, for-else
---
#### While문
- while문은 조건식이 참인 경우 반복적으로 코드를 실행
    - 조건이 참인 경우 들여쓰기 되어있는 코드 블록이 실행됨
    - 코드 블록이 모두 실행되고, 다시 조건식을 검사하며 반복적으로 실행됨
    - while문은 무한 루프를 하지 않도록 종료 조건이 반드시 필요함
#### 복합 연산자(In-Place Operator)
- 복합연산자는 연산과 할당(저장)을 합쳐놓은 것
    - 예) 반복문을 통해 개수를 카운트 하는 경우(+=, -= 등) 
---
## python tutor
- 구글에서 검색 - 사이트 입장 - 코드 입력 - visual~ 클릭하면 파이썬 코드를 시각화해서 보여줌
---
#### for문
- for문은 시퀀스(string, tuple, list, range)를 포함한 순회 가능한 객체(iterable)의 요소를 모두 순회
    - 처음부터 끝까지 모두 순회하므로 별도의 종료 조건이 필요하지 않음
- Iterable
    - 순회할 수 있는 자료형(string, list, dict, tuple, range, set 등)
    순회형 함수(**range**, **enumerate**)
        - enumerate()는 (index, value) 형태의 tuple로 구성된 열거 객체를 반환
            - enumerate(변수값,strat = x)하면 x부터 시작 
    ```
    for 변수명 in iterable:
    ```
### List Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법
```
[code for 변수 in iterable]
[code for 변수 in iterable if 조건식]
```
ex)
```python
# 1~3 세제곱 리스트 만들기
cubic_list=[]
for number in range(1,4):
    cubic_list.append(nummber ** 3)
print(cuvic_list) 
#[1, 8, 27]
cubic_list = [number ** 3 for number in rnage(1,4)]
#[1, 8, 27]
#같음
```
### Dictionary Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 딕셔너리를 간결하게 생성하는 방법
```
{key: vlaue for 변수 in iterable}
{key: vlaue for 변수 in iterable if 조건식}
```
ex)
```python
# 1~3 세제곱 딕셔너리 만들기
cubic_dict={}
for number in range(1,4):
    cubic_dict[nummber] = number ** 3)
print(cuvic_dict) 
# {1: 1, 2: 8, 3: 27}
cubic_dict = {number: number ** 3 for number in rnage(1,4)}
# {1: 1, 2: 8, 3: 27}
#같음
```
---
### 반복문 제어
- break
    - 반복문을 종료
- continue
    - continue 이후의 코드 블록은 수행하지 않고, 다음 반복을 수행
- for - else
    - 끝까지 반복문을 실행한 이후에 else문 실행
        - break를 통해 중간에 종료되는 경우 else문은 실행되지 않음
- pass
    - 아무것도 하지 않음(문법적으로 필요하지만, 할 일이 없을 때 사용)
    - 특별히 할 일이 없을 때 자리를 채우는 용도로 사용(빨리 테스트 할 때 사용)
    - continue와 다른점은 pass는 바로 다음줄로 가지만 continue는 그 반복을 마치고 다음 반복으로 넘어감
    - **반복문이 아니어도 사용 가능**
![반복문 제어 형식](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B0%98%EB%B3%B5%EB%AC%B8%20%EC%A0%9C%EC%96%B4%20%ED%98%95%EC%8B%9D.JPG)
---
---
## 함수
- 함수 기초
- 함수의 결과값(Output)
- 함수의 입력(Input)
- 함수의 범위(Scope)
- 함수의 문서화(Doc-string)
- 함수 응용
---
### 함수를 사용하는 이유
- Decomposition(분해)
    - 기능을 분해하고
    - 재사용 가능하게 만들고
- Abstraction(추상화)
    - 복잡한 내용을 모르더라도 사용할 수 있도록(스마트폰처럼)
    - 재사용성과 가독성, 생산성
    - 사실 내부 구조를 변경할 게 아니라면 몰라도 무방
        - 그것이 함수의 장점이자 프로그래밍의 매력
        - 스마트폰의 원리를 잘 몰라도 우리는 잘 사용할 수 있음
---
### 함수의 종류
- 함수는 크게 3가지로 분류
    - 내장함수(파이썬 개발자가 만들어서 자동으로 설치됨)
        - 파이썬에 기본적으로 포함된 함수
    - 외장함수(다른 개발자가 만들어서 불러와야 함)
        - import문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수
    - 사용자 정의 함수(내가 만듦)
        - 직접 사용자가 만드는 함수
---
### 함수의 정의
- 함수(Function)
    - 특정한 기능을 하는 코드의 조각(묶음)
    - 특정 코드를 매번 다시 작성하지 않고, 필요시에만 호출하여 간편히 사용

### 함수 기본 구조
- 선언(생성)과 호출(사용)(define & call)
- 입력(input)
- 문서화(docstring)
- 범위(scope)
- 결과값(output)
---
#### 선언(생성)과 호출(사용)(define & call)
- 함수의 선언은 def키워드를 활용
- 들여쓰기를 통해 Function body(실행될 코드블록)을 작성함
    - Docstring은 함수 body 앞에 선택적으로 작성 가능
        - 작성 시에는 반드시 첫번째 문장에 문자열 """
- 함수는 parameter를 넘겨줄 수 있음
- 함수는 동작 후에 return을 통해 결과값을 전달함
- return이 나오면 뒤도 신경 안쓰고 자동으로 함수 종료
- 함수는 함수명()으로 호출하여 사용
    - parameter가 있는 경우, 함수명(값1, 값2, ...)로 호출
---
#### 함수의 정의
- 함수를 사용하기 위해서는 먼저 함수를 정의해야 함
```
def name (parameters(재료))
    """
    Docstring(문서화) - 거의 안쓰고 앞에 # 주석을 많이 씀
    """
    내용(return) (function body)
```
---
#### 입력(input)
- **Parameter**와 **Argument**
    - Parameter(매개변수, 인수) : 함수를 정의할 때, 함수 내부에서 사용되는 변수
    - Argument(인자) : 함수를 호출할 때, 넣어준 값
- **Argument**란?
    - 함수 호출 시 함수의 parameter를 통해 전달되는 값
    - Argument는 소괄호 안에 할당 func_name(argument)
        - 필수 Argument : 반드시 전달되어야 하는 argument
        - 선택 Argument : 값을 전달하지 않아도 되는 경우는 기본값이 전달
    - **Positional Arguments**
        - 기본적으로 함수 호출시 Argument는 위치에 따라 함수 내에 전달됨
        ![Positional Arguments](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Positional%20Arguments.JPG?raw=true)
    - **Keyword Arguments**
        - 직접 변수의 이름으로 특정 Argument를 전달할 수 있음
        - Keyword Argument 다음에 Positional Argument를 활용할 수 없음
        ![Keyword Arguments](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Keyword%20Arguments.JPG?raw=true)
    - **Default Arguments Values**
        - 기본값을 지정하여 함수 호출 시 argument값을 설정하지 않도록 함
            -  정의된 것보다 더 적은 개수의 argument들로 호출될 수 있음
        ![Default Arguments Values](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Defalut%20Arguments%20Values.JPG?raw=true)
    - 정해지지 않은 여러개의 Arguments 처리
        - print 함수의 Argument 개수가 변해도 잘 동작함 - **애스터리스크**(Asterisk)혹은 언패킹 연산자라고 불리는 * 덕분
- **가변인자**(*args)
    - 여러개의 Positional Argument를 하나의 필수 parameter로 받아서 사용
    - 몇개의 Positional Argument를 받을 지 모르는 함수를 정의할때 사용
    ![가변인자](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EA%B0%80%EB%B3%80%EC%9D%B8%EC%9E%90.JPG?raw=true)
    - 반드시 받아야하는 키워드 인자와, 추가적인 키워드 인자를 구분해서 사용할 수 있음
    - *은 스퀸스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어 헤치는 연산자
        - 주로 튜플이나 리스트를 언패킹 하는데 사용
        - *을 활용하여 가변인자를 만들 수 있음
- **패킹 / 언패킹**
    - **패킹**
    여러개의 데이터를 묶어서 변수에 할당하는 것
        ![패킹](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%8C%A8%ED%82%B9.JPG?raw=true)
    -  **언패킹**
    시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
        ![언패킹](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%96%B8%ED%8C%A8%ED%82%B9.JPG?raw=true)
        - 언패킹시 변수의 개수와 할당하고자 하는 요소의 갯수가 동일해야함
        - 언패킹시 왼쪽의 변수에 asterisk(*)를 붙이면, 할당하고 남은 요소를 리스트에 담을 수 있음
        ![asterisk](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/asterisk.JPG?raw=true)
- **가변 키워드 인자**(**kwargs)
    - 몇 개의 키워드 인자를 받을 지 모르는 함수를 정의할 때 유용
    - **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **을 붙여 표현
    ![가변키워드인자](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EA%B0%80%EB%B3%80%20%ED%82%A4%EC%9B%8C%EB%93%9C%20%EC%9D%B8%EC%9E%90.JPG?raw=true)
    **key는 문자열로 쓰면 안됨(' '안쓰기)**
    - 반드시 받아야하는 키워드 인자와, 추가적인 키워드 인자를 구분해서 사용할 수 있음
- 가변 인자(*args)와 가변 키워드 인자(**kwargs) 동시 사용 가능
---
### 문서화(Docstring)
- 함수의 body위에 """내용"""을 입력 써도되고 안써도 됨
---
### 범위(Scope)
- 함수는 코드 내부에 local socpe를 생성하며, 그 외의 공간인 global scooe로 구분
- **scope**
    - **global scope** : 코드 어디에서든 참조할 수 있는 공간
    - **local scope** : 함수가 만든 scope. 함수 내부에서만 참조 가능
- **variable**
    - **global variable** : global scope에 정의된 변수 
    - **local variable** : local scope에 정의된 변수
- **변수 수명주기**(lifecycle)
    - 변수는 각자의 수명주기(lifecycle)가 존재
        - **built-in scope**
            파이썬이 실행된 이후부터 영원히 유지
        - **global scope**
            모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
        - **local scope**
            함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지
- 이름 검색 규칙(Name Resolution)
    - 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있음
    - 아래와 같은 순서로 이름을 찾아나가며, **LEGB Rule**이라고 부름
        - Local scope : 지역범위(현재 작업중인 범위)
        - Enclosed scope : 지역 범위 한단계 위 범위
        - Global scope : 최상단에 위차한 범위
        - Built-in scope : 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든 것) - print()등
    - 함수 내에서는 바깥 scope의 변수에 접근 가능하나 수정은 할 수 없음
    - 가장 작은 범위부터 찾아간다는 내용
- **global** 문
    - 현재 코드 블록 전체에 적용되며, 나열된 식별자(이름)이 global variable임을 나타냄
        - global에 나열된 이름은 같은 코드 블록에서 global 앞에 등장할 수 없음
        - global에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함
    - 관련 에러
        - 함수에서 global 선언 전에 print()를 하면 에러남
        - **parameter는 global을 사용할 수 없다.**
- **nonlocal**
    - global을 제외하고 **가장 가까운(둘러싸고 있는) scope의 변수를 연결**하도록 함
        - nonlocal에 나열된 이름은 같은 코드블록에서 nonlocal앞에 등장할 수 없음
        - nonlocal에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함
    - global과는 달리 **이미 존재하는 이름과의 연결**만 가능함
- 함수의 범위 주의사항
    - 기본적으로 함수에서 선언된 변수는 Local scope에 생성되며, 함수 종료 시 사라짐
    - 해당 scope에 변수가 없는 경우 LEGB rule에 의해 이름 검색
        - 변수에 **접근은 가능**, **수정은 불가능**
        - 값을 할당하는 경우 해당 scop의 이름공간에 새롭게 생성되기 떄문
        - 단, **함수 내에서 필요한 상위 scope 변수는 argument로 넘겨서 활용할 것**
    - 상위 scope에 있는 변수를 수정하고 싶다면 global, nonlocal키워드 활용가능
        - 코드 복잡해지면 변수의 변경을 추적하기 어렵고, 오류가 발생할 수 있기 떄문에 가급적 사용하지 않는 것을 권장
        - **함수로 값을 바꾸고자 한다면 항상 argument로 넘기고 리턴 값을 사용**하는 것을 추천
---
### 결과값(Output)
- Void function
    - 명시적인 return값이 없는 경우, None을 반환하고 종료
- Value returning function
    - 함수 실행 후, return문을 통해 값 반환
    - return을 하게 되면, 값 반환 후 함수가 바로 종료
```
주의 - print vs return
- print함수와 return의 차이점
    - print를 사용하면 호출될 때마다 값이 출력됨(주로 테스트를 위해 사용)
    - 데이터 처리를 위해서는 return 사용
- REPL(Read-Eval-Print Loop)(코랩, 주피터노트북처럼 한 줄씩 보여주는 것) 환경에서는 마지막으로 
작성된 코드의 리턴값을 보여주므로 같은 동작을 하는 것으로 착각할 수 있음
```
- 튜플을 활용하여 두개 이상의 값 반환
```
return x-y, x+y  <-이런 형태
```
- 함수 반환 정리
    - return X -> None - Void function
    - return O -> 하나로 반환
        - 여러개 원하면 Tuple 활용(리스트와 같은 컨테이너도 가능)
---
### 함수 응용
**내장함수**
- 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형(type이 내장되어 있음)
- **map(function,iterable)**
    - 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과를 map object로 반환
    - 알고리즘 문제 풀이시 input값들을 숫자로 바로 활용하고 싶을 때 사용
- **filter(function, iterable)**
    - 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과가 True인 것들을 filter object로 반환
- **zip(\*iterables)**
    - 복수의 iterable을 모아 튜플을 원소로 하는 zip object를 반환
    - 가로, 세로를 바꿀 때 주로 사용
- **lambda**
    - lambda parameter :표현식
        - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명함수라고도 불림
    - 특징
        - return문을 가질 수 없음
        - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
    - 장점
        - 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
        - def를 사용할 수 없는 곳에서도 사용 가능
    ![람다함수](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%9E%8C%EB%8B%A4%ED%95%A8%EC%88%98.JPG?raw=true)
- **재귀함수**(recursive function)
    - 자기 자신을 호출하는 함수
    - 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용
        - 알고리즘 중 재귀함수로 로직을 표현하기 쉬운 경우가 있음(예 - 점화식)
        - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성
    ```
    예시 ) Factorial (n!)
    f(4) = 4 * f(3)
    f(3) = 3 * f(2)
    f(2) = 2 * f(1)
    f(1) = 1 -> base case로 수렴
    ```
    - 재귀함수 주의사항
        - 재귀함수는 base case에 도달할 때 까지 함수를 호출함
        - 메모리 스택이 넘치게 되면(stack overflow) 프로그램이 동작하지 않게 됨
        - 파이썬에서는 최대 재귀깊이(maximum recursion depth)가 1000번으로, 호출횟수가 이를 넘어가게 되면 Recursion Error 발생
    - 반복문과 재귀함수 비교
        - 재귀함수는 반복문으로 항상 변환 가능
        - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수 사용
        - 재귀 호출은 변수 사용을 줄일 수 있음
        - 재귀호출은 입력 값이 커질수록 연산 속도가 오래걸림
---
---
## 모듈(module)
- **모듈** : 합, 평균, 표준편차 등 자주쓰는 기능(함수)들을 하나의 파일로 묶은 것
- **패키지**(package) : 다양한 파일을 하나의 폴더로 묶은것
- **라이브러리**(library) : 다양한 패키지를 하나의 묶음으로 묶은 것
- **pip** : 이것을 관리하는 관리자
- **가상환경** : 패키지의 활용 공간
---
### 모듈과 패키지
**1. 모듈**
- 특정 기능을 하는 코드를 파이썬 파일(.py)단위로 작성한 것

**2. 패키지**
- 특정 기능과 관련된 여러 모듈의 집합
- 패키지 안에는 또 다른 서브 패키지를 포함
```
inport module
from module import var, function, Class
from module import * - 전체 불러오기

inport module과 from module import * 의 차이
전자는 module.var, module.function 으로 접근해야 하지만 후자는 바로 var, function으로 접근 가능
as 닉네임 으로 불러오면 닉네임.var 등으로 쓸 수 있음 - 긴 모듈이름 짧게 변경하고 싶을 때 사용

from package import module
from package.module import var, function, Class
```
---
#### 모듈
- 파이썬에 기본적으로 설치된 모듈과 내장함수
    - ex) random.py
- 파이썬 패키지 관리자(pip)
    - PyPI(Python Package Index)에 저장된 외부 패키지들을 설치하도록 도와주는 패키지 관리 시스템
    - **패키지 설치**
        - 최신버전/ 특정버전/ 최소버전을 명시해 설치 가능
        - 이미 설치되있는 경우 이를 아리고 아무것도 안함
        ```
        $ pip install package
        $ pip install package == 1.0.5
        $ pip install 'package >= 1.0.4'
        basg, cmd에서 모두 사용되는 명령어
        ```
    - **패키지 삭제**
        - pip는 패키지 업그레이드시 자동으로 과거버전을 지워줌
        ```
        $ pip uninstall package
        ```
    - **패키지 목록** 및 **특정 패키지 정보**
        ```
        $ pip list
        $ pip show package
        ```
    - **패키지 관리하기**
        - 아래의 명령어들로 패키지 목록을 관리, 설치 가능
        - 일반적으로 패키지를 기록하는 파일의 이름은 requirements.txt로 정의함
        ```
        $ pip freeze > requirements.txt - 박제(저장)
        $ pip install -r requirements.txt - 집에서 다운
        ```
---
#### 사용자 모듈과 패키지
- 패키지는 여러 모듈/하위패키지로 구조화
    - 활용 예시: package.module
- 모든 폴더에는 \__init__.py를 만들어 패키지로 인식
    - python 3.3부터는 파일이 없어도 되지만, 하위버전 호환 및 프레임워크 등에서의 동작을 위해 파일 생성을 권장 
---
---
## 가상환경
- 파이썬 표준 라이브러리가 아닌 회부 패키지와 모듈을 사용하는 경우 모두 pip를 통해 설치를 해야함
- 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음
    - 과거 외주 프로젝트 - django버전 2.x
    - 신규 회사 프로젝트 - django버전 3.x
- 이러한 경우 가상환경을 만들어 프로젝트별로 독립적인 패키지를 관리할 수 있음
- 가상환경을 만들고 관리하는데 사용되는 모듈(파이썬 버전 3.5부터)
- 특정 디렉토리에 가상환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음
    - 특정 폴더에 가상 환경이(패키지 집합 폴더 등) 있고 실행환경(bash 등) 에서 가상환경을 활성화시켜 해당 폴더에 있는 패키지를 관리/사용함
- 가상환경 생성
    - 가상환경을 생성하면, 해당 디렉토리에 별도의 파이썬 패키지가 설치됨
    ```
    $ python -m venv 폴더명
    ```
- 가상환경 활성화/비활성화
    - 아래의 명령어를 통해 가상환경 활성화
    ```
    venv는 가상환경을 포함하는 디렉토리의 경로
    bash - $ source venv/bin/activate
    cmd - C:\> venv\Scripts\activate.bat
    PowerShell - PS C:\> venv\Scripts\Activate.ps1
    ```
    - 비활성화는 $ deactivate 명령어 사용
- 동일 컴퓨터 프로젝트별 가상환경 설정 가능

---
---

## 데이터 구조

#### 데이터 구조 활용
- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
    - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
    - 객체의 기능(추후 객체 지향 프로그래밍에서 학습)
    - **데이터구조.메서드()**형태로 활용
        - 예)
        ``` py
        List.append(10)
        String.split() 
        ```
- 파이썬 공식 문서의 표기법
    - python구문이 아니며, 문법을 표현하기 위한것
    예시에서 old, new는 필수, [, count]는 선택적 인자를 의미
    ```py
    str.replace(old,new[, count])
    ```
### 순서가 있는 데이터 구조
#### 문자열(String Type)
- 문자들의 나열(sequence of characters)
    - 모든 문자는 str타입(변경 불가능한 immutable)
- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
    - 문자열을 묶을 때 동일한 문장부호를 활용
    - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지해야함

- 문자열 조회/탐색 및 검증 메서드
![문자열 조회/탐색 및 검증 메서드]()
    - .find(x)
        - x의 첫 번째 위치를 반환, 없으면 -1을 반환함(**오류가 나지 않는다.**)
    - .index(x)
        - x의 첫 번째 위치를 반환, 없으면 **오류 발생**
- 문자열 관련 검증 메서드
    - isdecimal() < .isdigit() < .isnumeric()
    - 숫자만          수           숫자와 비슷한거
- 문자열 변경 메서드
![문자열 변경 메서드]()
    - .replace(old, new[, count])
        - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
        - count를 지정하면 해당 개수만큼만 시행
    - .strip([chars])
        - 특정 문자를 지정하면(양쪽(strip)을 제거하거나 왼쪽(lstrip) 또는 오른쪽(rstrip)을 제거)
        - 문자열을 지정하지 않으면 공백을 제거함
    - .split(set = None, maxsplit = -1)
        - 문자열을 특정한 단위로 나눠 리스트로 반환
            - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음.
            - maxsplit이 -1인경우에는 제한이 없음.
    - 'separator'.join([iterable])
        - 반복 가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환
            - iterable에 문자열이 아닌 값이 있으면 TypeError발생
#### 리스트(List)
- 리스트는 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
- 리스트는 대괄호([]) 혹은 list()를 통해 생성
    - 파이썬에서는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음 
    - 생성된 이후 내용 변경이 가능 -> 가변 자료형
    - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
    - 값에 대한 접근은 list[i]
!(리스트 메서드)[]