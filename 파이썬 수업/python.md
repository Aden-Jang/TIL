
# Python

## 프로그래밍 학습 마인드셋(OT)

- **개념 구조화** 하기 in 프로그래밍
    - 개념의 정의
    - 개념의 포함관계
    - 두 개념의 차이점
- 기본기 탄탄하게 쌓기
    - 코드를 작성하지 않고 프로그래밍 배우기는 불가능.
    - 지루하더라도 기본기가 중요!!!
- **동료 학습**(Peer Learning)
    - 상호 작용을 기반으로 한 학습
    - 친구에게 배운 개념 설명
    - 친구 코드의 에러 함께 해결
    - 모르는 내용을 서로 질문/대답 하면서 지식의 빈틈 채우기
    - 장점
        - 현업 기반의 학습 환경
        - 실제 회사에서도 함께 일하게 됨
        - 커뮤니케이션 스킬이 증진
        - 즉 동료학습이 취업에 도움이 된다~

---

## 프로그래밍이란?

### 프로그래밍의 정의

- 프로그램을 만드는 행위(프로그램+ing)
- 컴퓨터에게 일을 시키기 위해서 프로그램을 만드는 행위 - 프로그램을 만드는 사람은 **프로그래머(소프트웨어 개발자)**
    - 소프트웨어 , 코딩 - 엄밀히 따지면 다르지만 프로그램과 유사한 의미로 사용

#### 프로그램이란?

- 특정 작업을 수행하는 일련의 명령어들의 모음
- 컴퓨터가 해야할 일들이 순서대로 적혀있는 것

#### 프로그래밍 언어란?

- 언어란?
    - 자신의 생각을 나타내고 전달하기 위해 사용하는 체계
    - 문법적으로 맞고, 언어 공동체 내에서 이해될 수 있는 말의 집합
- 컴퓨터는 기계어로 소통.
    - 기계어 - 0과 1로 모든 것을 표현(2진법)
    - 처음 컴퓨터가 발명될 때 전기 신호로 전기가 들어왔는지(1), 안들어왔는지(0) 확인하는 방법으로 시작 - 지금까지 사용
    - 하지만 프로그래밍 하기 위해 기계어를 알 필요는 없다.
- 기계어의 대안으로 사람이 이해할 수 있는 새로운 언어 - **프로그래밍 언어** 개발
    - 사람이 이해할 수 있는 문자로 구성
    - 기본적인 규칙과 문법이 존재
- 프로그래밍 언어의 구성
    - 소스코드
        - 프로그래밍 언어로 작성된 프로그램
    - 번역기(interpreter 또는 compiler)
        - 소스코드를 컴퓨터가 이해할 수 있는 기계어로 번역
        - **파이썬의 경우 인터프리터**를 사용
    
---

## 파이썬이란?

### 파이썬을 배워야 하는 이유

- 알고리즘 코딩 테스트에 유리
    - 알고리즘 코딩테스트에서는 Python이 2위(선호도 조사)
    - 코딩 테스트의 유형이 다양해지면서 변칙적인 유형에 대응하기 쉬운 파이썬이 유리해짐 - 결과 최근 3년간 파이썬이 급증
    - 대회를 준비한다면 C를 추천하지만 입사를 위한 코테는 Python추천
- 구현 코딩 테스트에 유리
    - 유용한 라이브러리 중 최소한만 사용해 프로그램을 개발할 수 있어 가장 유리한 언어
    - 실행시간이 매우 중요한 문제 유형이 아닌 이상 파이썬으로 코테를 준비하는 것이 최선의 선택이다.
- 가장 인기 많은 언어
    - 프로그래밍의 인기 척도를 사용하는 PYPL Index, TIOBE Index에서 2022년 6월기준 1위
    - AI 개발, 데이터 분석, 웹 프로그래밍, 업무 자동화 등 활용분야가 늘어나 많은 회사에서 도입 중
- 그나마 배우기 쉽다
    - 파이썬은 다른 프로그래밍 언어보다 문법이 간결하고, 유연함(변수에 별도의 타입 저장이 필요 없음)
    - 비교적 쉽게 마스터하고, 프로그래밍 사고에 집중할 수 있음

---

### 파이썬의 특징

- **인터프리터**(Interpreter) 언어
    - 파이썬은 소스코드를 기계어로 변환할 때 통역(interprete) 하듯이 1줄씩 변환
- **객체 지향 프로그래밍**(Object Oriented Programming)
    - 현대 프로그래밍의 기본적인 설계 방법론으로 자리잡은 객체 지향 프로그래밍
    - 모든 것이 객체로 구현되어 있음

---

### 파이썬 개발환경

- 파이썬 개발 환경 종류
    - IDE(Intergrated development encironment)
        - 통합개발 환경의 약자로 개발에 필요한 다양하고 강력한 기능들을 모아둔 프로그램
        - 보통 개발은 IDE를 이용함
        - VSCode, Pycharm등
    - Jupyter Notebook
        - 문법 학습을 위한 최적의 도구로, 소스코드와 함께 실행 결과와 마크다운 저장 가능
        - open source기반의 웹 플랫폼 및 어플리케이션으로 파이썬을 비롯한 다양한 프로그래밍 언어를 지원하며 셀단위의 실행이 가능한 것이 특징
        - 인공지능 할때 자주 사용 수업에서는 실시간으로 결과를 확인하며 학습하는데 용이해 사용 예정
    - IDLE(Intergrated Development and Learning Environment)
    - 코딩
        - 파이썬: Jupyter notebook, VSCode(실시간으로 결과를 확인하며 학습하기 위함)
        - 웹: VSCode
        - 알고리즘: Pycharm

---

### 파이썬 기초문법

#### 코드 스타일 가이드

- 파이썬에서 제안하는 스타일 가이드(강의에서 사용)
    - PEP8(https://www.python.org/dev/peps/pep-0008/)
    - 각 회사/ 프로젝트마다 따로 스타일 가이드를 설정하기도 함
    - Google Style guide 등
- 스타일 가이드를 지키지 않으면 코드의 가독성이 떨어진다.

#### 들여쓰기

- space 4칸(tab)
- 문장을 구분할 때 중괄호 대신 들여쓰기 사용

#### 주석("필수로 해야할 것")

- 코드에 대한 설명
- 코드에 영향을 주지 않으며 오로지 개발자를 위함
- 코드 이해에 도움이 되어 분석, 수정 용이해짐
- 실행에 영향을 미치지 않을 뿐더러 속도를 느리게 하지 않으며 용량을 늘리지 않음
- 한줄 주석
    - 내용 앞에 #을 입력
    - 한줄을 온전히 사용 가능, 코드 뒤에만도 사용 가능
- 여러줄 주석
    - 한 줄씩   # 을 이용하거나 """ 또는 ''' 으로 묶어서 표현
- 주석의 장점
    - 개발자에게 주석을 다는 습관은 매우 중요
    - 코드의 내용을 잘 이해할 수 있도록 작성
    - 가독성을 저해할 정도로 무분별한 사용은 자제
    - 코드를 쉽게 이해할 수 있어 코드 수정 및 협업에 유리

---

## 변수

컴퓨터가 값을 저장하고 이름을 매김 ex) dust = 60

데이터 저장 → 처리

### 변수란?

- 데이터를 저장하기 위해 사용
- 변수를 사용하면 복잡한 값들을 쉽게 사용할 수 있음(추상화)
- 동일 변수에 다른 데이터를 언제든 할당(저장)할 수 있기 때문에 ‘변수’라고 불림

**추상화** (변수를 사용해야하는 이유)

- 코드의 가독성 증가
- 숫자를 직접 적지 않고 의미 단위로 작성 가능
- 코드 수정이 용이해짐 - 가격 변경이 있더라도 1곳만 수정하면 됨
 
```
- 만약에 아메리카노 1잔을 시킨다?
    - print(2000) # 2000
- 아메리카노 1잔과 쿠키 1개
    - print(2000 + 2000) # 4000
- 모카 2잔에 레몬에이드 3잔 케잌 5개
    - print(3000 * 2 + 3500 * 3 * 4000 * 5) # 36500
```
- 실행하면 결과는 잘 나오지만 문제가 있음
    - 일일이 값을 넣는 것이 불편함
        - 숫자를 입력하다 보면 오타가 나서 잘못된 값을 넣을 수 있음
    - 코드를 알아보기 힘듦
        - 다른 사람이 코드를 이해할 수 없음
    - 고치기 어려운 코드
        - 만약 아메리카노 가격이 변경된다면?
            - 코드 여러곳을 수정해야함
- 간단한 코드지만 실제로 코드가 복잡해지면 심각한 문제

##### 변수의 할당

- 변수는 할당 연산자(=)를 통해 값을 할당(assignment)
```python
- 같은 값을 동시에 할당할 수 있음
    - americano = cookie = 2000
- 다른 값을 동시에 할당할 수 있음
    - americano, mocha = 2000, 3000
```
##### 각 변수의 값을 바꿔서 저장

- x = 10 y = 20 일 때 각각 값을 바꿔서 저장하는 코드

```python
# 방법 1) 임시 변수 활용
x, y = 10, 20
tmp = x
x = y
y = tmp
print(x, y) # 20, 10

# 방법 2) Pythonic!
x, y = 10, 20
y, x = x, y
print(x, y) #20 10
```

---

## **식별자**

- 변수 이름 규칙
    - 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성
    - 첫 글자에 숫자가 올 수 없음
    - 길이 제한이 없고, 대소문자를 구별
    - 다음의 키워드(keywords)는 예약어(reserved words)로 사용할 수 없음

![키워드](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%82%A4%EC%9B%8C%EB%93%9C.JPG)

- 내장함수나 모듈 등의 이름도 사용하지 말아야 함
    - print 등
    - 동작을 예상할 수 없게 임의로 값을 할당하게 되므로 범용적이지 않은 코드가 됨

---

## 연산자

#### 산술 연산자

기본적인 사칙연산 및 수식 계산

```python
+ - 덧셈
- - 뺄셈
* - 곱셉
/ - 나눗셈
// - 몫
** - 거듭제곱
```

##### 연산자 우선순위

- 기본적으로 수학에서 우선순위와 같음
- 괄호가 가장 먼저 계산, *,/가 +,-보다 먼저 계산

---

## 자료형

#### 자료형(Datatype) 분류

- 프로그래밍에서는 다양한 종류의 값(데이터)을 쓸 수 있음
    - 사용할 수 있는 데이터의 종류들을 자료형이라고 함

```python
Data Type - Boolean Type(불린형(참거짓))
	  - Numeric Type(수치형) - 정수형(int)
	                        - 실수형(float)
    	                        - 복소수(complex)
	  - String Type(문자열)
```

---

## 수치형

- 정수 자료형(int)
    - 0,100,-200등의 정수
- 진수 표현
    - 2진수(binary) : 0b
    - 8진수(octal) : 0c
    - 16진수(hexadecimal) : 0x
- 실수 자료형(float)
    - 유리수 무리수를 포함한 실수를 다루는 자료형
        - 0.1, 100.0, -0.0001 등
    - 실수의 값을 처리할 때 의도하지 않은 값이 나올 수 있음

```python
print(3.2 - 3.1) # 0.10000000000009
print(1.2 - 1.1) # 0.09999999999987
# 연산의 결과가 0.1이 아니다!
```

- 윈인은 부동 소수점 때문
    - 컴퓨터는 2진수, 사람은 10진법 사용
    - 10진수 0.1은 2진수는 0.0001100110011…같이 무한대로 반복됨
    - 무한대 숫자를 그대로 저장할 수 없어 사람이 사용하는 10진법의 근사값만 표시
    - 0.1의 경우 36028701896397/2**5이며 0.1에 가깝지만 정확히 동일하지 않음
    - 이런 과정에서 예상치 못한 결과가 나타남(Floating point rounding error라고 함)
- 해결책
    - 값을 비교하는 과정에서 정수가 아닌 실수면 주의할 것
    - 매우 작은수보다 작은지를 확인하거나 math 모듈 활용

![부동소수점 해결책](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%20%ED%95%B4%EA%B2%B0%EC%B1%85.JPG)

---

## 문자열 자료형

#### 문자열 자료형의 정의

- 모든 문자는 str타입
- 문자열은 ' 또는 "를 활용하여 표기
    - 문자열을 묶을 때 동일한 문장부호 활용
    - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

**중첩 따옴표**

- 따옴표 안에 따옴표를 표현할 경우
    - 작은따옴표가 들어있는 경우는 큰따옴표로, 큰따옴표가 들어있는 경우는 작은따옴표로 문자열 생성

**삼중 따옴표**

- 작은 따옴표나 큰따옴표를 삼중으로 사용(''', """)
    - 따옴표 안에 따옴표를 넣을 때 여러 줄을 나눠 입력할 때 편리

##### Escape sequence

- 역슬래시(\\)뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
- 띄어쓰기, 줄 바꿈과 같은 기능을 문자로 표현

```python
\n 줄바꿈
\t 탭
\r 캐리지 리턴
\0 널(NULL)
\\ \
\' 단일인용부호(')
\" 이중인용부호(")
```

EX)

```python
print('철수 \'안녕\' ')
print('이 다음은 엔터. \n 그리고 탭\t탭')
```

#### 문자열 연산

- 덧셈
    - 숫자형 연산 7+6은 13
        - 문자형 연산은 “Hello” + “World” = HelloWorld
    - 문자열을 더하면 문자열을 연결
    - 영어로는 String Concatenation이라고 함
    
- 곱셈
    - 2*3은 2+2+2 = 6
    - 문자열 “Python”*3은?
        - PythonPythonPython

#### String Interpolation(문자열을 변수를 활용해 만드는 법)

- %-formatting - 현재는 잘 안씀
- str.format()
- f-strings - python 3.6부터 이거 씀 위에는 거의 안씀

```python
name = 'Kim'
score = 4.5
print(f'Hello, {name}! 성적은 {score}')
# Hello, Kim! 성적은 4.5
```

- import Datetime - 시간을 다룰 수 있는 모듈

---

### **None**

- 파이썬 자료형 중 하나
- 값이 없음을 표현하기 위해 None 타입이 존재
- 일반적으로 반환값이 없는 함수에서 사용하기도 함

---

### **불린형(Boolean)**

- 논리 자료형으로 참과 거짓을 표현하는 자료형
- True 또는 False를 값으로 가짐
- 비교/논리연산에서 활용됨

---

### **비교 연산자**

- 수학에서 등호와 부등호와 동일한 개념
- 주로 조건문에 사용되며 값을 비교할 때 사용
- 결과는 True/False값을 리턴
    
![비교연산자](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B9%84%EA%B5%90%EC%97%B0%EC%82%B0%EC%9E%90.JPG)

---    

### **논리 연산자**

- 여러가지 조건이 있을 때
    - 모든 조건을 만족하거나(And), 여러 조건 중 하나만 만족해도 될 때(or) 특정 코드를 실행하고 싶을 때 사용
    - 일반적으로 비교연산자와 함께 사용됨
    - and, or, not
- and는 2개다 True인 경우에 True
- or은 1개라도 True면 True
```
- EX) 22시가 지나고 졸리면 True 졸리지 않으면 False →
    - hour=23 , status = ‘sleepy’
        - hour≥22 and status = ‘sleepy’ → True
    - hour=23 , status = ‘nice’
        - hour≥22 and status = ‘sleepy’ → False
```
- 주의할 점 / not연산자
    - Falsy : False는 아니지만 False로 취급되는 다양한 값
        - 0, 0.0, (), [], {}, None, “”(빈 문자열)
            - 1 → True , 0 → False
        - 이외에는 Truthy값으로 취급 
    - 논리연산자도 우선순위 존재
        - not, and, or 순으로 우선순위가 높음

#### 논리 연산자의 단축평가

- 결과가 확실한 경우 두번째 값은 확인하지 않고 첫번째 값 반환
- and 연산에서 첫번째 값이 False인 경우 무조건 False→첫번째 값 반환
- or 연산에서 첫번째 값이 True인 경우 무조건 True → 첫번째 값 반환
    
    ```python
    print(3 and 5) # 5 -> 둘다 True인지 확인하느라
    print(3 and 0) # 0 -> 둘다 True인지 확인하느라
    print(0 and 3) # 0 -> 첫 값이 False이므로 0반환 - 단축평가
    print(0 and 0) # 0
    
    print(5 or 3) # 5 -> 첫 값이 True이므로 5 반환 - 단축평가
    print(3 or 0) # 3 -> 첫 값이 True이므로 5 반환 - 단축평가
    print(0 or 3) # 3 -> 둘다 Fals인지 확인하느라
    print(0 or 0) # 0
    ```

---

## 컨테이너(자료구조)

### 컨테이너란?

- 여러 개의 값(데이터)을 담을 수 있는 것(객체)으로, 서로 다른 자료형을 저장할 수 있음
    - EX) List
- 컨테이너의 분류
    - 순서가 있는 데이터(Ordered) vs. 순서가 없는 데이터(Unordered)
    - 순서가 있다 ≠ 정렬되어 있다.

![컨테이너의 분류](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98%20%EB%B6%84%EB%A5%98.JPG)

---

## 리스트

- 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용 → [] 사용

#### 리스트의 생성과 접근

- 대괄호[] 혹은 list()를 통해 생성
    - 파이썬에서는 어떠한 자료형도 저장 가능하며 리스트 안에 리스트도 넣을 수 있음
    - 생성된 이후 내용 변경이 가능 → 가변 자료형
    - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
    - 값에 대한 접근은 list[i]
- type(자료명) → 자료의 형태를 나타내줌
#### 인덱스
- **인덱스는 0부터 시작**
- 뒤에서부터는 -1부터 사용 가능
- [0:2]이면 0,1 두개(뒤에 값 -1까지)
- [:b] 처음부터 b-1까지
- [a:] a부터 끝까지
- [a : b : c] a부터 b-1까지 c간격으로
---

## 튜플

-  여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용 → ()사용
- 리스트와 차이점은 생성 후, 담고있는 값 변경이 불가(불변 자료형)

#### 튜플 생성과 접근

- 소괄호(()) 혹은 tuple()을 통해 생성
- 튜플은 수정 불가능한 시퀀스로 인덱스로 접근 가능
- 값에대한 접근은 my_tuple[i]

#### 튜플 생성 주의사항

- 단일 항목의 경우
    - 하나의 항목으로 구성된 튜플을 생성 시 값 뒤에 쉼표를 붙여야함
- 복수 항목의 경우
    - 마지막 항목에 붙은 쉼표는 없어도 되지만, 넣는 것을 권장(Trailing comma)

#### 튜플 대입

- 우변의 값을 좌변의 변수에 한 번에 할당하는 과정
- 튜플은 일반적으로 파이썬 내부에서 활용
    - 추후 함수에서 복수의 값을 반환할 때에도 활용

---

## Range

### range의 정의

- 숫자의 시퀀스를 나타내기 위해 사용
- 주로 반복문과 함께 사용됨

#### range의 사용 방법

- 기본형 : range(n)
    - 0부터 n-1까지의 숫자의 시퀀스
- 범위 지정 : range(n,m)
    - n부터 m-1까지의 숫자의 시퀀스
- 기본형 : range(n,m,s)
    - n부터 m-1까지 s만큼 증가시키며  숫자의 시퀀스
    - s가 음수이면 거꾸로 감소시키며 나타냄

---

## 슬라이싱 연산자

### 시퀀스를 특정 단위로 슬라이싱

- 인덱스와 콜론을 사용하여 문자열의 특정 부분만 잘라낼 수 있음
- 슬라이싱을 이용하여 문자열을 나타낼 때 콜론을 기준으로 앞 인덱스에 해당하는 문자는 포함되지만 뒤 인덱스에 해당 문자는 미포함

```python
# 리스트
print([1, 2, 3, 5][1:4]) # [2, 3, 5]
# range
print(range(10)[5:8] # range(5, 8)
# 문자열
print('abcd'[2:4]) # cd
```

### 시퀀스를 k간격으로 슬라이싱

```python
# 리스트
print([1, 2, 3, 5][0:4:2]) # [1, 3]
# range
print(range(10)[1:5:3]) # range(1, 5, 3)
# 문자열
print('abcdefg'[1:3:2]) # b
```

### 문자열 슬라이싱 예제

- s=’abcdefghi’
- s[::] → ’abcdefghi’
    - s[0:len(s):1]과 동일
- s[::-1] → ‘ihgfedcba’
    - s[-1:-(len(s)+1):-1]과 동일

---

## 비 시퀀스형 컨테이너

### 셋(Set)

- set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
    - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
    - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
    - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재하지 않음
    - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입 변경, 삭제 가능 → 가변자료형(mutable)

#### 셋 생성

- 중괄호({}) 혹은 set()을 통해 생성
    - 빈 set을 만들기 위해서는 set()을 반드시 활용해야함
- 순서가 없어 별도의 값에 접근할 수 없음

#### 셋 사용하기

- 셋을 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음
    - 단, 이후 순서가 무시되므로 순서가 중요한 경우 사용할 수 없음
- 순서가 중요한 경우는 셋으로 바꾸면 절대 안됨

#### 셋 연산자

```python
| : 합집합
& : 교집합
- : 차집합
^ : 대칭차집합
여집합은 없음
```

---

## 딕셔너리

### **딕셔너리의 정의**

- 키-값 쌍으로 이뤄진 자료형(3.7부터는 ordered, 이하 버전은 unordered)
- Dictionary의 키
    - 키는 변경 불가능한 데이터(immutable)만 활용 가능
        - string, interger, float, boolean, tuple, range
- 각 키의 값
    - 어떠한 형태든 관계없음

### **딕셔너리 생성**

- 중괄호({}) 혹은 dict()을 통해 생성
- key를 통해 value에 접근

---

## 형 변환(Typecasting)

### 형 변환이란?

- 파이썬에서 데이터 형태는 서로 변환할 수 있음
1. 암시적 형 변환(Implicit) - 파이썬이 하면
    - 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우 (**자동**)
        - bool
        - Numeric type (int, float)
    - 절대 의도하면 안됨
2. 명시적 형 변환(Explicit) - 개발자가 하면
    - 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환하는 경우 (**의도적**)
        - int
            - str, float → int
            - 단, 형식에 맞는 문자열만 정수로 변환 가능
        - float
            - str(참고), int → float
            - 단, 형식에 맞는 문자열만 float로 변환 가능
        - str
            - int, float, list, tuple, dict → str
    
![형 변환](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%98%95%EB%B3%80%ED%99%98.JPG)

---
---
## 제어문
- 조건문과 반복문으로 나뉨
- 파이썬은 기본적으로 위에서 부터 아래로 차례대로 명령을 수행
- 특정 상황에서 따라 코드를 선택적으로 실행(분기/조건)하거나 계속하여 실행(반복)하는 제어가 필요함
- 제어문은 순서도 표현 가능
---
### 조건문
- 참/거짓을 판단할 수 있는 조건식과 함께 사용

#### 기본 형식
- 조건에는 참/거짓에 대한 조건식
    - 조건이 참인 경우 이후 들여쓰기 되어있는 코드 블록을 실행
    - 이외의 경우 else이후 들여쓰기 되어있는 코드 블록을 실행
        - else는 선택적으로 활용할 수 있음
```python
num = int(input("숫자 입력"))
if num % 2 == 0:
    print("짝수")
else:
    print("홀수")
```
#### 복수 조건문
- 복수의 조건식을 활용 할 경우 elif를 활용하여 표현함
    ```
    if 조건 :
    elif 조건 :
    ```
#### 중첩 조건문
- 조건문은 다른 조건문에 중첩되어 사용될 수 있음
    - 들여쓰기에 유의하여 작성할 것
        ```
        if 조건 :
            if 조건:
        else:
        ```
#### 조건 표현식
- 조건 표현식을 일반적으로 조건에 따라 값을 정할 때 활용
- 삼항연산자(Ternary Operator)로 부르기도 함
```
true인 경우 값 if 조건 else false인 경우 값
(왼참 if 조건 else 오거)
```
- 실습 - 절댓값을 저장하는 코드
```python
value = num if num >= 0 else -num
```
---
### 반복문
- 특정 조건을 만족할 때까지 같은 동작을 계속 반복하고 싶을 때 사용
#### 반복문의 종류
- while문
    - 종료 조건에 해당하는 코드를 통해 반복문을 종료시켜야 함
- for 문
    - 반복 가능한 객체를 모두 순회하면 종료(별도의 종료 조건이 필요 없음)
- 반복 제어
    - break, continue, for-else
---
#### While문
- while문은 조건식이 참인 경우 반복적으로 코드를 실행
    - 조건이 참인 경우 들여쓰기 되어있는 코드 블록이 실행됨
    - 코드 블록이 모두 실행되고, 다시 조건식을 검사하며 반복적으로 실행됨
    - while문은 무한 루프를 하지 않도록 종료 조건이 반드시 필요함
#### 복합 연산자(In-Place Operator)
- 복합연산자는 연산과 할당(저장)을 합쳐놓은 것
    - 예) 반복문을 통해 개수를 카운트 하는 경우(+=, -= 등) 
---
## python tutor
- 구글에서 검색 - 사이트 입장 - 코드 입력 - visual~ 클릭하면 파이썬 코드를 시각화해서 보여줌
---
#### for문
- for문은 시퀀스(string, tuple, list, range)를 포함한 순회 가능한 객체(iterable)의 요소를 모두 순회
    - 처음부터 끝까지 모두 순회하므로 별도의 종료 조건이 필요하지 않음
- Iterable
    - 순회할 수 있는 자료형(string, list, dict, tuple, range, set 등)
    순회형 함수(**range**, **enumerate**)
        - enumerate()는 (index, value) 형태의 tuple로 구성된 열거 객체를 반환
            - enumerate(변수값,strat = x)하면 x부터 시작 
    ```
    for 변수명 in iterable:
    ```
### List Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법
```
[code for 변수 in iterable]
[code for 변수 in iterable if 조건식]
```
ex)
```python
# 1~3 세제곱 리스트 만들기
cubic_list=[]
for number in range(1,4):
    cubic_list.append(nummber ** 3)
print(cuvic_list) 
#[1, 8, 27]
cubic_list = [number ** 3 for number in rnage(1,4)]
#[1, 8, 27]
#같음
```
### Dictionary Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 딕셔너리를 간결하게 생성하는 방법
```
{key: vlaue for 변수 in iterable}
{key: vlaue for 변수 in iterable if 조건식}
```
ex)
```python
# 1~3 세제곱 딕셔너리 만들기
cubic_dict={}
for number in range(1,4):
    cubic_dict[nummber] = number ** 3)
print(cuvic_dict) 
# {1: 1, 2: 8, 3: 27}
cubic_dict = {number: number ** 3 for number in rnage(1,4)}
# {1: 1, 2: 8, 3: 27}
#같음
```
---
### 반복문 제어
- break
    - 반복문을 종료
- continue
    - continue 이후의 코드 블록은 수행하지 않고, 다음 반복을 수행
- for - else
    - 끝까지 반복문을 실행한 이후에 else문 실행
        - break를 통해 중간에 종료되는 경우 else문은 실행되지 않음
- pass
    - 아무것도 하지 않음(문법적으로 필요하지만, 할 일이 없을 때 사용)
    - 특별히 할 일이 없을 때 자리를 채우는 용도로 사용(빨리 테스트 할 때 사용)
    - continue와 다른점은 pass는 바로 다음줄로 가지만 continue는 그 반복을 마치고 다음 반복으로 넘어감
    - **반복문이 아니어도 사용 가능**
![반복문 제어 형식](https://raw.githubusercontent.com/Aden-Jang/TIL/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%B0%98%EB%B3%B5%EB%AC%B8%20%EC%A0%9C%EC%96%B4%20%ED%98%95%EC%8B%9D.JPG)
---
---
## 함수
- 함수 기초
- 함수의 결과값(Output)
- 함수의 입력(Input)
- 함수의 범위(Scope)
- 함수의 문서화(Doc-string)
- 함수 응용
---
### 함수를 사용하는 이유
- Decomposition(분해)
    - 기능을 분해하고
    - 재사용 가능하게 만들고
- Abstraction(추상화)
    - 복잡한 내용을 모르더라도 사용할 수 있도록(스마트폰처럼)
    - 재사용성과 가독성, 생산성
    - 사실 내부 구조를 변경할 게 아니라면 몰라도 무방
        - 그것이 함수의 장점이자 프로그래밍의 매력
        - 스마트폰의 원리를 잘 몰라도 우리는 잘 사용할 수 있음
---
### 함수의 종류
- 함수는 크게 3가지로 분류
    - 내장함수(파이썬 개발자가 만들어서 자동으로 설치됨)
        - 파이썬에 기본적으로 포함된 함수
    - 외장함수(다른 개발자가 만들어서 불러와야 함)
        - import문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수
    - 사용자 정의 함수(내가 만듦)
        - 직접 사용자가 만드는 함수
---
### 함수의 정의
- 함수(Function)
    - 특정한 기능을 하는 코드의 조각(묶음)
    - 특정 코드를 매번 다시 작성하지 않고, 필요시에만 호출하여 간편히 사용

### 함수 기본 구조
- 선언(생성)과 호출(사용)(define & call)
- 입력(input)
- 문서화(docstring)
- 범위(scope)
- 결과값(output)
---
#### 선언(생성)과 호출(사용)(define & call)
- 함수의 선언은 def키워드를 활용
- 들여쓰기를 통해 Function body(실행될 코드블록)을 작성함
    - Docstring은 함수 body 앞에 선택적으로 작성 가능
        - 작성 시에는 반드시 첫번째 문장에 문자열 """
- 함수는 parameter를 넘겨줄 수 있음
- 함수는 동작 후에 return을 통해 결과값을 전달함
- return이 나오면 뒤도 신경 안쓰고 자동으로 함수 종료
- 함수는 함수명()으로 호출하여 사용
    - parameter가 있는 경우, 함수명(값1, 값2, ...)로 호출
---
#### 함수의 정의
- 함수를 사용하기 위해서는 먼저 함수를 정의해야 함
```
def name (parameters(재료))
    """
    Docstring(문서화) - 거의 안쓰고 앞에 # 주석을 많이 씀
    """
    내용(return) (function body)
```
---
#### 입력(input)
- **Parameter**와 **Argument**
    - Parameter(매개변수, 인수) : 함수를 정의할 때, 함수 내부에서 사용되는 변수
    - Argument(인자) : 함수를 호출할 때, 넣어준 값
- **Argument**란?
    - 함수 호출 시 함수의 parameter를 통해 전달되는 값
    - Argument는 소괄호 안에 할당 func_name(argument)
        - 필수 Argument : 반드시 전달되어야 하는 argument
        - 선택 Argument : 값을 전달하지 않아도 되는 경우는 기본값이 전달
    - **Positional Arguments**
        - 기본적으로 함수 호출시 Argument는 위치에 따라 함수 내에 전달됨
        ![Positional Arguments](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Positional%20Arguments.JPG?raw=true)
    - **Keyword Arguments**
        - 직접 변수의 이름으로 특정 Argument를 전달할 수 있음
        - Keyword Argument 다음에 Positional Argument를 활용할 수 없음
        ![Keyword Arguments](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Keyword%20Arguments.JPG?raw=true)
    - **Default Arguments Values**
        - 기본값을 지정하여 함수 호출 시 argument값을 설정하지 않도록 함
            -  정의된 것보다 더 적은 개수의 argument들로 호출될 수 있음
        ![Default Arguments Values](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/Defalut%20Arguments%20Values.JPG?raw=true)
    - 정해지지 않은 여러개의 Arguments 처리
        - print 함수의 Argument 개수가 변해도 잘 동작함 - **애스터리스크**(Asterisk)혹은 언패킹 연산자라고 불리는 * 덕분
- **가변인자**(*args)
    - 여러개의 Positional Argument를 하나의 필수 parameter로 받아서 사용
    - 몇개의 Positional Argument를 받을 지 모르는 함수를 정의할때 사용
    ![가변인자](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EA%B0%80%EB%B3%80%EC%9D%B8%EC%9E%90.JPG?raw=true)
    - 반드시 받아야하는 키워드 인자와, 추가적인 키워드 인자를 구분해서 사용할 수 있음
    - *은 스퀸스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어 헤치는 연산자
        - 주로 튜플이나 리스트를 언패킹 하는데 사용
        - *을 활용하여 가변인자를 만들 수 있음
- **패킹 / 언패킹**
    - **패킹**
    여러개의 데이터를 묶어서 변수에 할당하는 것
        ![패킹](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%8C%A8%ED%82%B9.JPG?raw=true)
    -  **언패킹**
    시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
        ![언패킹](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%96%B8%ED%8C%A8%ED%82%B9.JPG?raw=true)
        - 언패킹시 변수의 개수와 할당하고자 하는 요소의 갯수가 동일해야함
        - 언패킹시 왼쪽의 변수에 asterisk(*)를 붙이면, 할당하고 남은 요소를 리스트에 담을 수 있음
        ![asterisk](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/asterisk.JPG?raw=true)
- **가변 키워드 인자**(**kwargs)
    - 몇 개의 키워드 인자를 받을 지 모르는 함수를 정의할 때 유용
    - **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **을 붙여 표현
    ![가변키워드인자](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EA%B0%80%EB%B3%80%20%ED%82%A4%EC%9B%8C%EB%93%9C%20%EC%9D%B8%EC%9E%90.JPG?raw=true)
    **key는 문자열로 쓰면 안됨(' '안쓰기)**
    - 반드시 받아야하는 키워드 인자와, 추가적인 키워드 인자를 구분해서 사용할 수 있음
- 가변 인자(*args)와 가변 키워드 인자(**kwargs) 동시 사용 가능
---
### 문서화(Docstring)
- 함수의 body위에 """내용"""을 입력 써도되고 안써도 됨
---
### 범위(Scope)
- 함수는 코드 내부에 local socpe를 생성하며, 그 외의 공간인 global scooe로 구분
- **scope**
    - **global scope** : 코드 어디에서든 참조할 수 있는 공간
    - **local scope** : 함수가 만든 scope. 함수 내부에서만 참조 가능
- **variable**
    - **global variable** : global scope에 정의된 변수 
    - **local variable** : local scope에 정의된 변수
- **변수 수명주기**(lifecycle)
    - 변수는 각자의 수명주기(lifecycle)가 존재
        - **built-in scope**
            파이썬이 실행된 이후부터 영원히 유지
        - **global scope**
            모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
        - **local scope**
            함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지
- 이름 검색 규칙(Name Resolution)
    - 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있음
    - 아래와 같은 순서로 이름을 찾아나가며, **LEGB Rule**이라고 부름
        - Local scope : 지역범위(현재 작업중인 범위)
        - Enclosed scope : 지역 범위 한단계 위 범위
        - Global scope : 최상단에 위차한 범위
        - Built-in scope : 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든 것) - print()등
    - 함수 내에서는 바깥 scope의 변수에 접근 가능하나 수정은 할 수 없음
    - 가장 작은 범위부터 찾아간다는 내용
- **global** 문
    - 현재 코드 블록 전체에 적용되며, 나열된 식별자(이름)이 global variable임을 나타냄
        - global에 나열된 이름은 같은 코드 블록에서 global 앞에 등장할 수 없음
        - global에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함
    - 관련 에러
        - 함수에서 global 선언 전에 print()를 하면 에러남
        - **parameter는 global을 사용할 수 없다.**
- **nonlocal**
    - global을 제외하고 **가장 가까운(둘러싸고 있는) scope의 변수를 연결**하도록 함
        - nonlocal에 나열된 이름은 같은 코드블록에서 nonlocal앞에 등장할 수 없음
        - nonlocal에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함
    - global과는 달리 **이미 존재하는 이름과의 연결**만 가능함
- 함수의 범위 주의사항
    - 기본적으로 함수에서 선언된 변수는 Local scope에 생성되며, 함수 종료 시 사라짐
    - 해당 scope에 변수가 없는 경우 LEGB rule에 의해 이름 검색
        - 변수에 **접근은 가능**, **수정은 불가능**
        - 값을 할당하는 경우 해당 scop의 이름공간에 새롭게 생성되기 떄문
        - 단, **함수 내에서 필요한 상위 scope 변수는 argument로 넘겨서 활용할 것**
    - 상위 scope에 있는 변수를 수정하고 싶다면 global, nonlocal키워드 활용가능
        - 코드 복잡해지면 변수의 변경을 추적하기 어렵고, 오류가 발생할 수 있기 떄문에 가급적 사용하지 않는 것을 권장
        - **함수로 값을 바꾸고자 한다면 항상 argument로 넘기고 리턴 값을 사용**하는 것을 추천
---
### 결과값(Output)
- Void function
    - 명시적인 return값이 없는 경우, None을 반환하고 종료
- Value returning function
    - 함수 실행 후, return문을 통해 값 반환
    - return을 하게 되면, 값 반환 후 함수가 바로 종료
```
주의 - print vs return
- print함수와 return의 차이점
    - print를 사용하면 호출될 때마다 값이 출력됨(주로 테스트를 위해 사용)
    - 데이터 처리를 위해서는 return 사용
- REPL(Read-Eval-Print Loop)(코랩, 주피터노트북처럼 한 줄씩 보여주는 것) 환경에서는 마지막으로 
작성된 코드의 리턴값을 보여주므로 같은 동작을 하는 것으로 착각할 수 있음
```
- 튜플을 활용하여 두개 이상의 값 반환
```
return x-y, x+y  <-이런 형태
```
- 함수 반환 정리
    - return X -> None - Void function
    - return O -> 하나로 반환
        - 여러개 원하면 Tuple 활용(리스트와 같은 컨테이너도 가능)
---
### 함수 응용
**내장함수**
- 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형(type이 내장되어 있음)
- **map(function,iterable)**
    - 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과를 map object로 반환
    - 알고리즘 문제 풀이시 input값들을 숫자로 바로 활용하고 싶을 때 사용
- **filter(function, iterable)**
    - 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과가 True인 것들을 filter object로 반환
- **zip(\*iterables)**
    - 복수의 iterable을 모아 튜플을 원소로 하는 zip object를 반환
    - 가로, 세로를 바꿀 때 주로 사용
- **lambda**
    - lambda parameter :표현식
        - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명함수라고도 불림
    - 특징
        - return문을 가질 수 없음
        - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
    - 장점
        - 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
        - def를 사용할 수 없는 곳에서도 사용 가능
    ![람다함수](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%9E%8C%EB%8B%A4%ED%95%A8%EC%88%98.JPG?raw=true)
- **재귀함수**(recursive function)
    - 자기 자신을 호출하는 함수
    - 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용
        - 알고리즘 중 재귀함수로 로직을 표현하기 쉬운 경우가 있음(예 - 점화식)
        - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성
    ```
    예시 ) Factorial (n!)
    f(4) = 4 * f(3)
    f(3) = 3 * f(2)
    f(2) = 2 * f(1)
    f(1) = 1 -> base case로 수렴
    ```
    - 재귀함수 주의사항
        - 재귀함수는 base case에 도달할 때 까지 함수를 호출함
        - 메모리 스택이 넘치게 되면(stack overflow) 프로그램이 동작하지 않게 됨
        - 파이썬에서는 최대 재귀깊이(maximum recursion depth)가 1000번으로, 호출횟수가 이를 넘어가게 되면 Recursion Error 발생
    - 반복문과 재귀함수 비교
        - 재귀함수는 반복문으로 항상 변환 가능
        - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수 사용
        - 재귀 호출은 변수 사용을 줄일 수 있음
        - 재귀호출은 입력 값이 커질수록 연산 속도가 오래걸림
---
---
## 모듈(module)
- **모듈** : 합, 평균, 표준편차 등 자주쓰는 기능(함수)들을 하나의 파일로 묶은 것
- **패키지**(package) : 다양한 파일을 하나의 폴더로 묶은것
- **라이브러리**(library) : 다양한 패키지를 하나의 묶음으로 묶은 것
- **pip** : 이것을 관리하는 관리자
- **가상환경** : 패키지의 활용 공간
---
### 모듈과 패키지
**1. 모듈**
- 특정 기능을 하는 코드를 파이썬 파일(.py)단위로 작성한 것

**2. 패키지**
- 특정 기능과 관련된 여러 모듈의 집합
- 패키지 안에는 또 다른 서브 패키지를 포함
```
inport module
from module import var, function, Class
from module import * - 전체 불러오기

inport module과 from module import * 의 차이
전자는 module.var, module.function 으로 접근해야 하지만 후자는 바로 var, function으로 접근 가능
as 닉네임 으로 불러오면 닉네임.var 등으로 쓸 수 있음 - 긴 모듈이름 짧게 변경하고 싶을 때 사용

from package import module
from package.module import var, function, Class
```
---
#### 모듈
- 파이썬에 기본적으로 설치된 모듈과 내장함수
    - ex) random.py
- 파이썬 패키지 관리자(pip)
    - PyPI(Python Package Index)에 저장된 외부 패키지들을 설치하도록 도와주는 패키지 관리 시스템
    - **패키지 설치**
        - 최신버전/ 특정버전/ 최소버전을 명시해 설치 가능
        - 이미 설치되있는 경우 이를 아리고 아무것도 안함
        ```
        $ pip install package
        $ pip install package == 1.0.5
        $ pip install 'package >= 1.0.4'
        bash, cmd에서 모두 사용되는 명령어
        ```
    - **패키지 삭제**
        - pip는 패키지 업그레이드시 자동으로 과거버전을 지워줌
        ```
        $ pip uninstall package
        ```
    - **패키지 목록** 및 **특정 패키지 정보**
        ```
        $ pip list
        $ pip show package
        ```
    - **패키지 관리하기**
        - 아래의 명령어들로 패키지 목록을 관리, 설치 가능
        - 일반적으로 패키지를 기록하는 파일의 이름은 requirements.txt로 정의함
        ```
        $ pip freeze > requirements.txt - 박제(저장)
        $ pip install -r requirements.txt - 집에서 다운
        ```
---
#### 사용자 모듈과 패키지
- 패키지는 여러 모듈/하위패키지로 구조화
    - 활용 예시: package.module
- 모든 폴더에는 \__init__.py를 만들어 패키지로 인식
    - python 3.3부터는 파일이 없어도 되지만, 하위버전 호환 및 프레임워크 등에서의 동작을 위해 파일 생성을 권장 
---
---
## 가상환경
- 파이썬 표준 라이브러리가 아닌 회부 패키지와 모듈을 사용하는 경우 모두 pip를 통해 설치를 해야함
- 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음
    - 과거 외주 프로젝트 - django버전 2.x
    - 신규 회사 프로젝트 - django버전 3.x
- 이러한 경우 가상환경을 만들어 프로젝트별로 독립적인 패키지를 관리할 수 있음
- 가상환경을 만들고 관리하는데 사용되는 모듈(파이썬 버전 3.5부터)
- 특정 디렉토리에 가상환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음
    - 특정 폴더에 가상 환경이(패키지 집합 폴더 등) 있고 실행환경(bash 등) 에서 가상환경을 활성화시켜 해당 폴더에 있는 패키지를 관리/사용함
- 가상환경 생성
    - 가상환경을 생성하면, 해당 디렉토리에 별도의 파이썬 패키지가 설치됨
    ```
    $ python -m venv 폴더명
    ```
- 가상환경 활성화/비활성화
    - 아래의 명령어를 통해 가상환경 활성화
    ```
    venv는 가상환경을 포함하는 디렉토리의 경로
    bash - $ source venv/bin/activate
    cmd - C:\> venv\Scripts\activate.bat
    PowerShell - PS C:\> venv\Scripts\Activate.ps1
    ```
    - 비활성화는 $ deactivate 명령어 사용
- 동일 컴퓨터 프로젝트별 가상환경 설정 가능

---
---

## 데이터 구조

#### 데이터 구조 활용
- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
    - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
    - 객체의 기능(추후 객체 지향 프로그래밍에서 학습)
    - **데이터구조.메서드()형태**로 활용
        - 예)
        ``` py
        List.append(10)
        String.split() 
        ```
- 파이썬 공식 문서의 표기법
    - python구문이 아니며, 문법을 표현하기 위한것
    예시에서 old, new는 필수, [, count]는 선택적 인자를 의미
    ```py
    str.replace(old,new[, count])
    ```
---
### 순서가 있는 데이터 구조
---
#### 문자열(String Type)
- 문자들의 나열(sequence of characters)
    - 모든 문자는 str타입(변경 불가능한 immutable)
- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
    - 문자열을 묶을 때 동일한 문장부호를 활용
    - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지해야함

- 문자열 조회/탐색 및 검증 메서드
![문자열 조회/탐색 및 검증 메서드](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EC%A1%B0%ED%9A%8C,%20%ED%83%90%EC%83%89%20%EB%B0%8F%20%EA%B2%80%EC%A6%9D%20%EB%A9%94%EC%84%9C%EB%93%9C.JPG?raw=true)
##### 문자열 조회/ 탐색
    - .find(x)
        - x의 첫 번째 위치를 반환, 없으면 -1을 반환함(**오류가 나지 않는다.**)
    - .index(x)
        - x의 첫 번째 위치를 반환, 없으면 **오류 발생**
- 문자열 관련 검증 메서드
    - isdecimal()(숫자만) ⊆ .isdigit()(수) ⊆ .isnumeric()(숫자와 비슷한거)
- 문자열 변경 메서드
![문자열 변경 메서드](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%B3%80%EA%B2%BD%20%EB%A9%94%EC%84%9C%EB%93%9C.JPG?raw=true)
##### 문자열 변경
    - .replace(old, new[, count])
        - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
        - count를 지정하면 해당 개수만큼만 시행
    - .strip([chars])
        - 특정 문자를 지정하면(양쪽(strip)을 제거하거나 왼쪽(lstrip) 또는 오른쪽(rstrip)을 제거)
        - 문자열을 지정하지 않으면 공백을 제거함
    - .split(set = None, maxsplit = -1)
        - 문자열을 특정한 단위로 나눠 리스트로 반환
            - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음.
            - maxsplit이 -1인경우에는 제한이 없음.
    - 'separator'.join([iterable])
        - 반복 가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환
            - iterable에 문자열이 아닌 값이 있으면 TypeError발생
---
#### 리스트(List)
- 리스트는 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
- 리스트는 대괄호([]) 혹은 list()를 통해 생성
    - 파이썬에서는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음 
    - 생성된 이후 내용 변경이 가능 -> 가변 자료형
    - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
    - 값에 대한 접근은 list[i]
![리스트 메서드](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EB%A9%94%EC%84%9C%EB%93%9C.JPG?raw=true)
##### 값 추가 및 삭제
    - .append(x)
        - 리스트에 값을 마지막에 추가함
    - .insert(i,x)
        - 정해진 위치 i에 x값을 추가함 
        - i가 리스트 길이보다 클 경우 맨 뒤에 추가 
    - .extend(iterable)
        - 리스트에 iterable의 항목을 추가함
    - .remove(x)
        - 리스트에서 값이 x인 것 삭제
        - 없는 것을 삭제할 경우 Value Error
    - .pop(i)
        - 정해진 위치 i에 있는 값을 삭제하고, 그 항목을 반환함
        - i가 지정되지 않으면, 마지막 항목을 삭제하고 반환함
    - .clear()
        - 모든 항목을 삭제함
##### 탐색 및 정렬
    - .index(x)
        - x값을 찾아 해당 index값을 반환
        - 없는 경우 ValueError
    - .count(x)
        - 원하는 값의 개수를 반환함
    - .sort()
        - 원본 리스트를 정렬함. None반환
        - sorted 함수와 비교할 것
            - sort는 원본을 변경
            - sroted는 복사해서 새로운 리스트 만듦
    - .reverse()
        - 순서를 반대로 뒤집음(정렬하는 것이 아님)
        - 원본을 변경함
---
### 튜플
- 튜플은 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
    - 리스트와의 차이점은 생성 후, 담고 있는 값 변경이 불가 (불변 자료형)
- 항상 소괄호 형태로 사용
- 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메서드만을 지원
- 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일
---
#### 멤버십 연산자
- 포함여부 확인
    - in 안에 있는지
    - not in 안에 없는지

#### 시퀀스형 연산자
- 산술연산자(+)
    - 시퀀스 간의 concatenation(연결/인쇄)
---
### 셋(Set)
- Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
    - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
    - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
    - 집합 연산이 가능(여집합 연산자는 따로 없음)
    - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입, 변경, 삭제 가능 -> 가변 자료형(mutable)
![셋 메서드](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%85%8B%20%EB%A9%94%EC%84%9C%EB%93%9C.JPG?raw=true)
##### 추가 및 변경
    - .add(elem)
        - 셋에 값을 추가
    - .update(*others)
        - 여러 값을 추가
##### 요소 삭제
    - .remove(elem)
        - set에서 삭제하고, 없으면 KeyError
    - .discard(elem)
        - set에서 삭제하고 없어도 에러가 발생하지 않음
##### 삭제
    - .pop()
        - 임의의 원소를 제거해 반환
##### 모두 삭제 
    - .clear
        - 모든 항목을 제거
##### 집합 관련 함수
    - s.isdisjoint(t)
        - 셋 s가 셋t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True반환(서로소)
        - 교집합이 없는가?
    - s.issubset(t)
        - 셋 s가 셋 t의 하위 셋인 경우, True반환
    - s.issuperset(t)
        - 셋 s가 셋 t의 상위 셋인 경우, True반환
---
### 딕셔너리
- 키-값 쌍으로 이뤄진 자료형 - 3.7부터는 ordered
- 딕셔너리의 키(key)
    - 키는 변경 불가능한 데이터(immutable)만 활용 가능
        - string, integer, float, boolean, tuple, range
- 딕셔너리의 값(vlaues)
    - 어떠한 형태든 관계 없음
![딕셔너리 메서드](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%20%EB%A9%94%EC%84%9C%EB%93%9C.JPG?raw=true)
##### 조회
    - .get(key[, default])
        - key를 통해 value를 가져옴
        - KeyError가 발생하지 않으며, default값을 설정할 수 있음(기본: None)
        - my_dict['']로 불러왔을 때 없으면 키에러
        - get을 쓰면 None으로 나옴
##### 추가 및 삭제
    - .pop(key[, default])
        - 키가 딕셔너리에 있으면 제거하고 해당 값을 반환
        - 그렇지 않으면 default를 반환
        - default값이 없으면 KeyError
    - .update()
        - 값을 제공하는 key, value로 덮어씀

---

## 얕은 복사와 깊은 복사
### 복사 방법
- 할당(Assignment)
- 얕은 복사(Shallow copy)
- 깊은 복사(Deep copy)
#### 할당
- 대입 연산자(=)
    - 리스트 복사 확인하기
    - 대입 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사 -> 리스트를 복사해 복사한 리스트를 변경해도 본 리스트가 같이 변경됨
```py
a=[1,2,3]
b=a
print(a,b) # [1,2,3] [1,2,3]
b[0] =5
print(a,b) # [5,2,3] [5,2,3]
```
#### 얕은 복사
- Slice연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)
```py
a=[1,2,3]
b=a[:]
print(a,b) # [1,2,3] [1,2,3]
b[0] =5
print(a,b) # [1,2,3] [5,2,3]
```
- **주의사항**
    - 복사하는 리스트의 원소가 주소를 참조하는 경우
    ```py
    a=[1,2,['a','b']]
    b=a[:]
    print(a,b) # [1,2,['a','b']] [1,2,['a','b']]
    b[2][0] = 0 
    print(a,b) # [1,2,['0','b']] [1,2,['0','b']]
    ```
#### 깊은 복사
- 리스트 복사 확인하기
```py
import copy
a=[1,2,['a','b']]
b=copy.deepcopy(a)
print(a,b) # [1,2,['a','b']] [1,2,['a','b']]
b[2][0] = 0 
print(a,b) # [1,2,['a','b']] [1,2,['0','b']]
```
---

## 객체 지향 프로그래밍 (OOP)
- **객체 지향 프로그래밍**은 컴퓨터 프로그래밍의 패러다임(방법론)중 하나이다. 
    - 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위
    - 즉 "객체"들의 모임으로 파악하고자 하는 것.
    - 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
#### 객체지향 프로그래밍이란?
- 프로그램을 여러개의 독립된 객체들과 그 객체간의 상호작용으로 파악하는 프로그래밍 방법
- **객체**는 정보(변수)와 행동(함수)을 묶어둔 것
- 예시
    - 콘서트
        - 가수 객체, 감독 객체, 관객 객체
- 서로 데이터와 기능(메서드)를 분리하고 추상화된 구조(인터페이스)
#### 절차지향 프로그래밍
- 과거에 사용했던 방법
    - 변수 -함수 - 함수 - 함수 - 변수 형태로 됨
    - 중간에 함수 바꾸기 힘듦 - 중간에 하나를 바꾸면 뒤에를 다 바꿔야함
    - 어디를 바꿔야 하는지 찾기 힘듦 - 전체를 훑어야 함
    - 이러한 단점을 해결하기 위해 객체지향 프로그래밍이 나옴
#### 객체지향 프로그램이 필요한 이유
- 현실세계를 프로그램 설계에 반영(추상화)
    - 현실세계가 너무 복잡해 추상화를 해야함
    - **추상화**란 복잡한 것을 숨기고 필요한 것을 드러내는 것.
#### 객체지향의 장/단점
- **장점**
    - 클래스 단위로 모듈화시켜 개발할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발에 적합
        - 니일 내일을 나눠 본인 일만 할 수 있기 때문에 협업에 유리
    - 필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉬움 
- **단점**
    - 설계 시 많은 노력과 시간이 필요함
        - 다양한 객체들의 상호 작용 구조를 만들기 위해 많은 시간과 노력이 필요
        - 간단한 프로그래밍에서는 객체지향을 안쓰는 것이 유리
    - 실행속도가 상대적으로 느림
        - 절차 지향 프로그래밍이 컴퓨터의 처리구조와 비슷해서 실행 속도가 빠름
        - 사람이 편하면 컴퓨터가 힘들다.(사람이 힘들면 컴퓨터가 편하다)

---

### OOP기초
#### 객체(컴퓨터 과학)
- 컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, 변수, 자료구조, 함수 또는 메서드가 될 수 있다.
- **속성**과 **행동**으로 구성된 모든 것
- 예시
    - 가수 이찬혁(객체로 바꾸면 이찬혁.랩하기() -> 어느새부터~, 이찬혁.직업 -> 가수)
    - 클래스(설계도) - 가수,  객체(실제 사례) - 이찬혁  
    - 속성(정보)(변수)
        - 직업: 가수
        - 생년월일: 1996년 9월 12일
        - 국적: 대한민국
    - 행동(동작)(함수-메서드)
        - 랩하기()
            어느새부터 힙합은 안멋져~
        - 댄스()
            두둠칫~~
        - Make_some_noise()
            와아아아아
    - 객체와 인스턴스
        - 클래스로 만든 객체를 인스턴스라고도 함
    ```
    이찬혁은 객체다(O)
    이찬혁은 인스턴스다(X)
    이찬혁은 가수의 인스턴스다(O)
    ```
    - 클래스 -> 타입 - 클래스를 만든다 == 타입을 만든다  
        - 타입(클래스)과 실제 사례(값)
            - [1, 2, 3], [1], [], ['hi']
            모두 리스트 타입(클래스)의 객체
            - '', 'hi', '파이썬'
            모두 문자열 타입(클래스)의 객체
- 파이썬은 모든 것이 객체(object)
    - 파이썬의 모든 것에는 속성과 행동이 존재
    - 코드 예시
    ```
    [3, 2, 1].sort()
    리스트.정렬()
    객체.행동()
    
    'banana'.upper()
    문자열.대문자로()
    객체.행동()
    ```
- 객체는 특정 타입의 인스턴스이다.
    ```
    123, 900, 5는 모두 int의 인스턴스
    'hello', 'bye'는 모두 string의 인스턴스
    [232, 89, 1], []은 모두 list의 인스턴스
    ```

---

#### 최종 정리
- 객체의 특징
    - 타입(type) : 어떤 연산자(operator))와 조작(method)이 가능한가?
    - 속성(attribute) : 어떤 상태(데이터)를 가지는가?
    - 조작법(method) : 어떤 행위(함수)를 할 수 있는가?
- 파이썬의 객체와 클래스
    - 객체(object) = 속성(attribute) + 기능(method)

---

### 객체와 클래스 문법
- 기본 문법
    - 클래스 정의 - 인스턴스를 만들기 위한 재료(정보와 행동의 설명을 적어둔 것)
    ```py
    class MyClass:
        pass
    ```
    - 인스턴스 생성
    ```py
    my_instance =  MyClass()
    ```
    - 메서드 호출
    ```py
    my_instance.my_method
    ```
    - 속성
    ```py
    my_instance.my_attribute
    ```
- 클래스와 인스턴스
    - 객체의 설계도(클래스)를 가지고, 객체(인스턴스)를 생성한다.
    - 클래스: 객체들의 분류 / 설계도(class)
    - 인스턴스: 하나하나의 실체 / 예(instance)
    **파이썬은 모든 것이 객체, 모든 객체는 특정 타입의 인스턴스**

---

#### 객체 비교하기
- ==
    - 동등한(equal)
    - 변수가 참조하는 객체가 동등한(내용이 같은)경우 True
    - 두 객체가 같아보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님
    - 주소가 달라도 값이 같으면 됨
- is
    - 동일한(identical)
    - 두 변수가 동일한 객체를 가리키는 경우 True
    - 주소까지 같아야함
```py 
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b, a is b) # True False

a = [1, 2, 3]
b = a
print(a == b, a is b) # True True
```
#### 속성(데이터, 정보, 상태) -> 변수
- 특정 데이터 타입 / 클래스의 객체들이 가지게 될 상태 / 데이터를 의미
- 클래스 변수 / 인스턴스 변수가 존재

---

#### 정리
객체 - 정보와 행동으로 나뉨
정보 - 클래스 변수 (- 공용), 인스턴스 변수 (- 개인용)로 나뉨

---

#### 인스턴스 변수
- 인스턴스 변수란?
    - 인스턴스가 개인적으로 가지고 있는 속성(나만 쓰는 것)
    - 각 인스턴스들의 고유한 변수
- 생성자 메서드(\_\_init__)에서 self.name으로 정의 - 첫번 째는 무조건 self
- 인스턴스가 생성된 이후 instance.name으로 접근 및 할당
![인스턴스 변수](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%20%EB%B3%80%EC%88%98.JPG?raw=true)

---

#### 클래스 변수
- 클래스 선언 내부에서 정의
- classname.name으로 접근 및 할당
![클래스 변수](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98.JPG?raw=true)
##### 클래스 변수 활용(사용자 수 계산하기)
- 사용자가 몇 명인지 확인하고 싶다면?
    - 인스턴스가 생성될 때마다 클래스 변수가 늘어나도록 설정하면 됨
![클래스 변수 활용](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98%20%ED%99%9C%EC%9A%A9.JPG?raw=true)
### 클래스 변수와 인스턴스 변수
- 클래스 변수는 변경할 때는 항상 클래스.클래스변수 형식으로 변경
- 인스턴스.변수가 없으면 클래스.변수가 자동으로 나옴
![클래스 변수와 인스턴스 변수](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B3%80%EC%88%98%EC%99%80%20%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%20%EB%B3%80%EC%88%98.JPG?raw=true)

---

### OOP 메서드
- 특정 데이터 타입 / 클래스의 객체에 공통적으로 적용 가능한 행위(함수)
- 메서드의 종류
    - 인스턴스 메서드
        - 인스턴스 (변수) 처리(개별 행동)
    - 클래스 메서드
        - 클래스 (변수) 처리
    - 정적 메서드
        - 나머지
---
#### 인스턴스 메서드
- 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
- 클래스 내부에 정의되는 메서드의 기본
- 호출 시, 첫번 째 인자로 인스턴스 자기자신(self)이 자동으로 전달됨
- **self가 있으면 인스턴스 메서드이다.**
- self
    - 인스턴스 자기자신
    - 파이썬에서 인스턴스 메서드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계
        - 매개변수 이름으로 self를 첫번째 인자로 정의
        - 다른 단어로 써도 작동하지만, 파이썬의 암묵적인 규칙
- 생성자(constructor) 메서드
    - 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
    - 인스턴스 변수들의 초기값을 설정
        - 인스턴스 생성
        - \_\_init__ 메서드 자동 호출
- 매직 메서드
    - Double underscore(__)(던더)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드로, 스페셜 메서드 혹은 매직 메서드라고 불림
    - 특정 상황에 자동으로 불리는 메서드
    - 예시
        - 객체의 특수 조작 행위를 지정함(함수, 연산자 등)
        - \_\_str__ : 해당 객체의 출력 형태를 지정
            - 프린트 함수를 호출할 때, 자동으로 호출
            - 어떤 인스턴스를 출력하면 \_\_str__의 return값이 출력
        - \_\_gt__ : 부등호 연산자(>, greater than)
- 소멸자(destructor) 메서드
    - 인스턴스 객체가 소멸(파괴)되기 직전에 호출되는 메서드
        - \_\_del__ : 메모리 삭제

---

#### 클래스 메서드
- 클래스가 사용할 메서드
- @classmethod 데코레이터를 사용하여 정의
- 호출 시, 첫번째 인자로 클래스(cls)가 전달됨
```py
@classmethod
def class_method(cls, arg1,...):
```
- **데코레이터**
    - 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
    - @데코레이터(함수명) 형태로 함수 위에 작성
    - 순서대로 적용되기 때문에 작성 순서가 중요
    - 데코레이터를 활용하면 쉽게 여러 함수를 원하는대로 변경할 수 있음
#### 클래스 메서드와 인스턴스 메서드
- 클래스 메서드 -> 클래스 변수 사용(cls)
- 인스턴스 메서드 -> 인스턴스 변수 사용(self)
- 그렇다면 인스턴스 변수, 클래스 변수 모두 사용하고 싶다면?
    - 클래스는 인스턴스 변수 사용이 불가능
    - 인스턴스 메서드는 클래스 변수, 인스턴스 변수 둘다 사용이 가능
    - 둘다 고치고 싶으면 인스턴스 메서드를 사용해야함

---

### 스태틱 메서드(정적 메서드)
- 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메서드
- 속성(데이터)을 다루지 않고 단지 기능(행동)만을 하는 메서드를 정의할 때 사용
- 인스턴스 변수, 클래스 변수 아무것도 사용하지 않을 경우 사용
    - 즉, 객체 상태나 클래스 상태를 수정할 수 없음
- @staticmethod 데코레이터를 사용하여 정의
- 일반 함수처럼 동작하지만, 클래스의 이름 공간에 귀속됨
    - 주로 해당 클래스로 한정하는 용도로 사용
    ```py
    @staticmethod
    def static_method(arg1,...):
    ```

---

#### 메서드 정리
- 인스턴스 메서드
    - 호출한 인스턴스를 의미하는 self 매개변수를 통해 인스턴스 조작
- 클래스 메서드
    - 클래스를 의미하는 cls매개변수를 통해 클래스를 조작
- 스태틱 메서드
    - 클래스 변수나 인스턴스 변수를 사용하지 않는 경우에 사용
    - 객체 상태나 클래스 상태를 수정할 수 없음

---

#### 인스턴스와 클래스 간의 이름공간(namespace)
- 클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
- 인스턴스를 만들면, 인스턴스 객체가 생성되고 이름 공간 생성
- 인스턴스에서 특정 속성에 접근하면, 인스턴스-클래스 순으로 탐색
![인스턴스와 클래스 간의 이름공간](https://github.com/Aden-Jang/TIL/blob/master/%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%88%98%EC%97%85/python.assets/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%99%80%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EA%B0%84%EC%9D%98%20%EC%9D%B4%EB%A6%84%20%EA%B3%B5%EA%B0%84.JPG?raw=true)

---

### 객체지향의 핵심 개념
- 객체지향의 핵심 4가지
    - 추상화
    - 상속
    - 다형성
    - 캡슐화

---

#### 추상화
- 현실 세계를 프로그램 설계에 반영
    - 복잡한 것은 숨기고, 필요한 것만 들어내기
- 변수, 함수, 클래스로 구분됨

---

#### 상속(extends)
- 두 클래스 사이 부모 - 자식 관계를 정립하는 것
- 클래스는 상속이 가능함
    - 모든 파이썬 클래스는 object를 상속받음
    ```py
    class ChildClass(ParentClass):
        pass
    ```
- 하위 클래스는 상위 클래스에 정의된 속성(데이터), 행동(메서드), 관계 및 제약 조건을 모두 상속받음
- 부모 클래스의 속성, 메서드가 자식 클래스에 상속되므로, 코드 재사용성이 높아짐

- 상속 없이 구현하는 경우
    - 학생 / 교수 정보를 나타내기 어려움
    - 메서드 중복 정의
- 상속을 통해 메서드 재사용 가능

##### 상속 관련 함수와 메서드
- isinstance(object, classinfo) - object가 classinfo로 만들어졌습니까? 라는의미
    - classinfo의 instance거나 subclass*인 경우 True
- issubclass(class,classinfo)
    - class가 classinfo의 subclass면 True
    - classinfo는 클래스 객체의 튜플일 수 있으며, classinfo의 모든 항목을 검사
- super()
    - 자식 클래스에서 부모클래스를 사용하고 싶은 경우


#### 상속 정리
- 파이썬의 모든 클래스는 object로부터 상속됨
- 부모 클래스의 모든 요소(속성, 메서드)가 상속됨
- super()를 통해 부모 클래스의 요소를 호출할 수 있음
- 메서드 오버라이딩을 통해 자식 클래스에서 재정의 가능함
- 상속관계에서 이름 공간은 인스턴스, 자식 클래스, 부모 클래스 순으로 탐색

#### 다중 상속
- 두 개 이상의 클래스를 상속 받는 경우
- 상속받은 모든 클래스의 요소를 활용 가능함
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정됨 - parentclass에 씌여진 순서
- **다중 상속 관련 함수와 메서드**
    - mro메서드(Method Resolution Order)
        - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
        - 기존의 인스턴스 -> 클래스 순으로 이름공간을 탐색하는 과정에서 상속관계에 있으면 인스턴스 -> 자식 클래스 -> 부모 클래스로 확장

---

#### 다형성 (Polymorphism)
- 여러 모양을 뜻하는 그리스어
- 동일한 메서드가 클래스에 따라 다르게 행동할 수 있음을 의미
- 즉, 서로 다른 클래스에 속해있는 객체들이 동일한 메시지에 대해 다른 방식으로 응답할 수 있음

##### 메서드 오버라이딩 - 덮어쓰기
- 상속받은 메서드를 재정의
    - 클래스 상속 시, 부모 클래스에서 정의한 메서드를 자식 클래스에서 변경
    - 부모 클래스의 메서드 이름과 기본 기능은 그대로 사용하지만, 특정 기능을 바꾸고 싶을 때 사용
    - 상속받은 클래스에서 같은 이름의 메서드로 덮어씀
    - 부모 클래스의 메서드를 실행시키고 싶은 경우 super를 활용
##### 메서드 오버로딩 
- 다른 언어에는 있지만 파이썬에는 없음 - *args를 쓰면 되기 때문

---

#### 캡슐화
- 객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단
    - 예시 : 주민등록번호
- 파이썬에서 암묵적으로 존재하지만, 언어적으로는 존재하지 않음 - 공식적으로 존재하지 않음
- 접근제어자 종류
    - Public Access Modifier
    - Protected Access Modifier
    - Private Access Modifier
- Public Member
    - 언더바 없이 시작하는 메서드나 속성
    - 어디서나 호출이 가능, 하위 클래스 override 허용
    - **일반적으로 작성되는 메서드와 속성의 대다수를 차지**
- Protected Member
    - 언더바 1개로 시작하는 메서드나 속성
    - 암묵적 규칙에 의해 부모 클래스 내부와 자식 클래스에서만 호출 가능
    - 하위 클래스 override 허용
- Private Member
    - 언더바 2개로 시작하는 메서드나 속성
    - 본 클래스 내부에서만 사용이 가능
    - 하위클래스 상속 및 호출 불가능(오류)
    - 외부 호출 불가능(오류)

##### getter 메서드와 setter메서드
- 변수에 접근할 수 있는 메서드를 별도로 생성
    - getter 메서드 : 변수의 값을 읽는 메서드(조회)
        - @property 데코레이터 사용
    - setter 메서드 : 변수의 값을 설정하는 성격의 메서드(변경)
        - @변수.setter 사용

#### 정리
- 추상화 - 복잡한 것을 숨기고 필요한 것을 드러냄
- 상속 - 부모 클래스로와 자식 클래스 관계를 맺음 -> 물려받아 재사용하기 위해(다른 클래스에 있는 것을 가지고옴)
- 다형성 - 이름은 같은데 동작은 다른 것 -> 오버라이딩 -> 부모것을 자식이 그대로 사용하기 싫어서 자식이 변경시키는 것
- 캡슐화 - 민감한 정보를 숨기는 것 -> getter, setter, _aaa, __aaa등을 사용

---

### 에러 / 예외처리
#### 디버깅
- 버그란?
    - 최초의 버그는 1945년 프로그래밍 언어의 일종인 코볼 발명자 그레이스 호퍼가 발견
    - 역사상 최초의 컴퓨터 버그는 Mark2라는 컴퓨터 회로에 벌레인 나방이 들어가 합선을 일으켜 비정상적으로 동작
    - 이때부터 소프트웨어에서 발생하는 문제를 버그라고 부름
- 디버깅의 정의
    - 잘못된 프로그램을 수정하는 것을 디버깅이라함 de(없앤다) + bugging(버그)
    - 에러 메시지가 발생하는 경우
        - 해당하는 위치를 찾아 메시지를 해결
    - 로직 에러가 발생하는 경우
        - 명시적인 에러 메시지 없이 예상과 다른 결과가 나온 경우
            - 정상적으로 동작하였던 코드 이후 작성된 코드를 생각해봄
            - 전체 코드를 살펴봄
            - 휴식을 가져봄
            - 누군가에게 설명해봄
- 코드의 상태를 신중하게 출력해가며 심사숙고하는 것보다 효과적인 디버깅 도구는 없다. - 브라이언 커니핸
- print함수 활용
    - 특정 함수 결과, 반복 / 조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠서 생각
- 개발환경(text deitor, IDE)등에서 제공하는 기능 활용
    - breakpoint, 변수 조회 등
- Python tutor활용 (단순 파이썬 코드인 경우)
- 뇌 컴파일, 눈디버깅

---

### 문법 에러(Syntax Error)
- Syntax Error가 발생하면, 파이썬 프로그램은 실행되지 않음
- 파일이름, 줄번호, ^ 문자를 통해 파이썬이 코드를 읽어나갈 때(parser)문제가 발생한 위치를 표현
- 줄에서 에러가 감지된 가장 앞의 위치를 가리키는 캐럿(caret)기호(^)를 표시
- Invalid syntax
    - 문법오류
- assign to literal
    - 잘못된 할당
- EOL(End of LIne) - 괄호를 안닫으면 주로 발생
- EOF(End of File) - 괄호를 안닫으면 주로 발생

---

### 예외(Exception)
- 실행 도중 예상치 못한 상황을 맞이하면, 프로그램 실행을 멈춤
    - 문장이나 표현식이 문법적으로 올바르더라도 발생하는 에러
- 실행중에 감지되는 에러들을 예외라고 부름
- 예외는 여러 타임으로 나타나고, 타입이 메시지의 일부로 출력됨
    - NameError, TypeError등은 발생한 예외타입의 종류(이름)
- 모든 내장 예외는 Exception Class를 상속받아 이뤄짐
- 사용자 정의 예외를 만들어 관리할 수 있음
- 종류
    - ZeroDivisionError - 0으로 나눌 때 발생
    - NameError - namesapce상에 이름이 없는 경우
    - TypeError - 타입 불일치
    - TypeError - argument 누락
    - TypeError - argument 개수 초과
    - TypeError - argument type 불일치
    - ValueError - 타입은 올바르나 값이 적절하지 않거나 없는 경우
    - IndexError - 인덱스가 존재하지 않거나 범위를 벗어나는 경우
    - KeyError - 해당 키가 존재하지 않는 경우
    - ModuleNotFoundError - 가상환경문제, 모듈을 설치하지 않았을 때, 위치가 다를 때 등
    - ImportError - Module은 있으나 존재하지 않는 클래스 / 함수를 가져오는 경우
    - KeyboardInterrupt - 임의로 프로그램을 종료하였을 때 - ctrl + c를 누르면 보통 멈춤
    - IndentationError - Indentation이 적절하지 않는 경우
- 파이썬 내장 예외(built-in0exceptions)
    - 파이썬 내장 예외의 클래스 계층 구조
![파이썬 내장 예외의 클래스 계층 구조]()

---

### 예외처리
- try문(statement) / except절(clause)을 이영하여 예외처리를 할 수 있음
- try 문
    - 오류가 발생할 가능성이 있는 코드를 실행
    - 예외가 발생되지 않으면, except 없이 실행 종료
- except 문
    - 예외가 발생하면, except절이 실행
    - 예외 상황을 처리하는 코드를 받아서 적절한 조치를 취함
- 처리순서
![처리순서]()
- 작성 방법
```
try:
    try 명령문
except 예외그룹-1 as 변수-1:
    예외처리 명령문 1
except 예외그룹-2 as 변수-2:
    예외처리 명령문 2
finally: <- 선택사항
    finally 명령문
```
- 에러 메시지 처리(as)
    - as키워드를 활용하여 원본 에러 메시지를 사용할 수 있음
        - 예외를 다른 이름에 대입

---

### 예외처리 종합
- try
    - 코드를 실행함
- except
    - try문에서 예외가 발생시 실행함
- else
    - try문에서 예외가 발생하지 않으면 실행함
- finally
    - 예외 발생 여부와 관계없이 항상 실행함